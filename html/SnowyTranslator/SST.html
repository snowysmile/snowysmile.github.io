<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" type="image/x-icon" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="static/Img/favicon/cat-in-leaves-512x512.png">
  <link rel="stylesheet" href="static/font.css">

  <link rel="stylesheet" href="https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
  <script src="https://code.jquery.com/jquery-3.7.0.min.js"></script>
  <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui-touch-punch/0.2.3/jquery.ui.touch-punch.min.js"></script>
  <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
  <style>
    html, body {
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
    }
    body {
      background-color: white;
      color: black;
    }
    .dark-mode,
    .dark-mode button,
    .dark-mode select,
    .dark-mode textarea,
    .dark-mode input,
    .dark-mode audio::-webkit-media-controls-panel {
      background-color: #555;
      color: #EEE;
    }
    .row-container {
      display: flex;
      flex-direction: row;
      flex-wrap: wrap;
      justify-content: center;
    }
    .layouts-container {
      display: flex;
      justify-content: center;
      align-items: center;
      flex-wrap: wrap;
      max-width: 600px;
    }
    .layouts-container button {
      justify-content: center;
      align-items: center;
      width: 110px;
      margin: 0;
      padding: 2px;
      overflow: hidden;
      font-size: 11px;
    }
    input[type="color"] {
      text-transform: uppercase;
    }
    table {
      border-collapse: collapse;
      border: 1px solid black;
    }
    th, td {
      padding: 5px;
      vertical-align: middle;
    }
    .input-table tr{
      border: 1px solid grey;
    }
    .input-table button{
      vertical-align: middle;
      height: 28px;
    }
    .input-table select {
      vertical-align: middle;
      height: 28px;
      width: 36px;
      font-family: "Monaco", monospace;
    }
    rt {
      font-size: 0.65em;
    }
    input[type="range"] {
      height: 10px;
    }
    #speechTextArea {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding-left: 20px;
      padding-right: 20px;
      height: 233px; /* Mainly Need to in update another place for the height */
      width: 1000px;
      overflow-y: auto;
    }
    #audioDownloadContainer {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
    #audioDownloadContainer td {
      border: 2px double #ccc;
    }
    .svg-stroke-text{
      font-size:50px;
      text-anchor:middle;
      fill:red;
    }
    .svg-stroke-layer-A{
      stroke-width:0.1em;
      stroke:orange;
    }
    .svg-stroke-layer-B{
      stroke-width:0.2em;
      stroke:yellow;
    }
    .svg-stroke-layer-C{
      stroke-width:0.3em;
      stroke:blue;
    }
    .stroke-text {
      z-index: 3;
      position: relative;
      line-height: 2;
    }
    .stroke-text-before {
      z-index: 2;
      position: absolute;
      top: 0;
      bottom: 0;
      line-height: 2;
    }
    .stroke-text-after {
      z-index: 1;
      position: absolute;
      top: 0;
      bottom: 0;
      line-height: 2;
    }
    .stroke-text:before {
      content: attr(stroke-data);
      z-index: -1;
      position: absolute;
      left: 0;
      top: 0;
      -webkit-text-stroke: var(--stroke-width-layer-0) var(--stroke-color-layer-0);
    }
    .stroke-text:after {
      content: attr(stroke-data);
      z-index: -2;
      position: absolute;
      left: 0;
      top: 0;
      -webkit-text-stroke: var(--stroke-width-layer-1) var(--stroke-color-layer-1);
    }

    .readButtonContainer button {
      font-size: 9px;
    }
    .phone-row-table tr{
      border: 1px dashed grey;
    }
    .phone-row-table td{
      font-size: 12px;
    }
    .phone-row-table td:first-child {
      width: 35%;
    }
    #jpExpAreaFrame {
      width: 1015px;
      border: 2px solid black;
    }
    #jpExpArea {
      width: 1000px;
      margin-top: 10px;
      margin-bottom: 10px;
    }
    #readingList {
      width: 800px;
    }
    input::-webkit-inner-spin-button {
      display: none;
    }
    @media screen and (max-width: 1000px) {
      body {
        background-color: #BEE2E4;
      }
      tr {
        display: block;
        width: 100%;
      }
      th, td {
        display: block;
        margin: 0 auto;
        padding: 2px;
        vertical-align: middle;
      }
      textarea {
        max-width: 93%;
        width: 93%;
      }
      iframe {
        max-width: 100%;
        width: 100%;
        display: block;
        height: auto;
        margin: 0 auto;
      }
      textarea {
        rows: 6;
        font-size: 20px;
      }
      #recognitionResult {
        height: 120px;
      }
      #speechTextArea {
        max-width: 95%;
        width: 95%;
      }
      .button-title {
        display: flex;
        justify-content: space-between;
      }
      .layouts-container {
        width: 100%;
      }
      .layouts-container button {
        height: 32px;
      }
      .phone-row-table tr {
        display: inline-flex;
      }
      .phone-new_line {
        display: block;
      }
      .reading-button-container {
        margin-left: 4px;
      }
      .reading-buttons-container select,
      .reading-buttons-container button {
        font-size: 11px;
        height: 22px;
      }
      .reading-buttons-container button{
        width:27px;
      }
      #apiKeyEditor input {
        max-width: 96%;
        width: 96%;
      }
      #readingList {
        max-width: 96%;
        width: 96%;
      }
      #jpExpAreaFrame {
        max-width: 96%;
        width: 96%;
      }
      #jpExpArea {
        max-width: 96%;
        width: 96%;
      }
    }
    @media screen and (max-width: 500px) {
      .phone-invisible {
        display: none;
      }
    }
    @media screen and (min-width: 1000px) {
      .phone-only {
        display: none;
      }
    }
  </style>

  <script>
    var runningEnvironment = 0;
    if (window.location.protocol === "file:") {
      console.log("⚙️ Running as a local file");
      runningEnvironment = 1;
    }
    else if (window.location.href.includes("localhost:")) {
      console.log("⚙️ Running on localhost");
      runningEnvironment = 2;
    }
    else {
      console.log("⚙️ Running on a web server");
      runningEnvironment = 3;
    }
  </script>
  <script>
    function printMap(map, str) {
      map.forEach((value, key) => {
        console.log(`key=${key}, value=${value}`);
      });
    }
    function copyMap(originalMap) {
      return new Map([...originalMap]);
    }
    function saveMap(originalMap) {
      const newArray = [];
      originalMap.forEach((value, key) => {
        if (value) {
          newArray.push(key);
        }
      });
      return newArray;
    }
    function copyConfig(originalConfig) {
      return JSON.parse(JSON.stringify(originalConfig));
    }
    const topTranslationCount = 2;
    var translationCount = 2; // Make it an integer, otherwise it will be a string
    var languagePosIdMap = {
      "ja": 0,
      "en": 1,
      "zh-TW": 2,
    };
    var configCounts = 3;
    var defaultConfig = {
      pageColor: "#FFFAFA", // #E8E8E8 (grey)
      curtainColor: "#9ACD32",
      curtainHeight: "233", // Config of speechTextArea's Height
      curtainWidth: "1000", // Config of speechTextArea's Width
      texts: ["きらきら光る、お空の星よ。",  // きらきらひかる、おそらのほしよ。
              "Twinkle, twinkle, little star, How I wonder what you are! ",
              "一閃一閃亮晶晶，滿天都是小星星。"],
              // まばたきしては、みんなをみてる。
              // Up above the world so high, Like a diamond in the sky.
              // 掛在天上放光明，好像許多小眼睛。
              // "1234567890 !@#$%^&*() abcdefg ABCDEFG",
      displayedTexts: ["<ruby> きらきら</ruby> <ruby> 光る <rt>ひかる</rt></ruby>、<ruby> お</ruby> <ruby> 空 <rt>そら</rt></ruby> <ruby> の</ruby> <ruby> 星 <rt>ほし</rt></ruby> <ruby> よ</ruby>。",
        "<ruby>Twinkle <rt>ˈtwɪŋkəl</rt> </ruby>, <ruby>twinkle <rt>ˈtwɪŋkəl</rt> </ruby>, <ruby>little <rt>ˈlɪtəl</rt> </ruby> <ruby>star <rt>stɑr</rt> </ruby>, <ruby>How <rt>haʊ</rt> </ruby> <ruby>I <rt>aɪ</rt> </ruby> <ruby>wonder <rt>ˈwʌndər</rt> </ruby> <ruby>what <rt>wɑt</rt> </ruby> <ruby>you <rt>ju</rt> </ruby> <ruby>are <rt>ɑr</rt> </ruby>!",
        "&nbsp;<ruby>一<rt>&nbsp;yī&nbsp;</rt></ruby>&nbsp;<ruby>閃<rt>&nbsp;shǎn&nbsp;</rt></ruby>&nbsp;<ruby>一<rt>&nbsp;yī&nbsp;</rt></ruby>&nbsp;<ruby>閃<rt>&nbsp;shǎn&nbsp;</rt></ruby>&nbsp;<ruby>亮<rt>&nbsp;liàng&nbsp;</rt></ruby>&nbsp;<ruby>晶<rt>&nbsp;jīng&nbsp;</rt></ruby>&nbsp;<ruby>晶<rt>&nbsp;jīng&nbsp;</rt></ruby>，&nbsp;<ruby>滿<rt>&nbsp;mǎn&nbsp;</rt></ruby>&nbsp;<ruby>天<rt>&nbsp;tiān&nbsp;</rt></ruby>&nbsp;<ruby>都<rt>&nbsp;dōu&nbsp;</rt></ruby>&nbsp;<ruby>是<rt>&nbsp;shì&nbsp;</rt></ruby>&nbsp;<ruby>小<rt>&nbsp;xiǎo&nbsp;</rt></ruby>&nbsp;<ruby>星<rt>&nbsp;xīng&nbsp;</rt></ruby>&nbsp;<ruby>星<rt>&nbsp;xīng&nbsp;</rt></ruby>。"],
      textFontColors: ["#000000", "#000000", "#000000"],
      textFontSizes: [22, 19, 17], //px
      textFontWeights: [500, 500, 500],
      textFontFamilies: ["NotoSansCJKjp", "NotoSansCJKjp", "NotoSansCJKjp"],
      textStrokeColors: [["#FFFFFF", "#FFB7C5"], ["#FFFFFF", "#FFD500"], ["#FFFFFF", "#FF0033"]], // #1FDDFF blue
      textStrokeWidths: [[0, 0], [0, 0], [0, 0]], //em // [0.2, 0.6], [0.2, 0.6], [0.2, 0.6]
      textShadowColors: ["#FFEEBB", "#FFEEBB", "#FFEEBB"],
      textShadowBlurRadius: [0, 0, 0], //em
      textMargins: [30, 12, 12], //px
      textMarginBottom: 16, //px
      apiKeys: ["", "", "", ""],
      speechOverInterval: 2800, //ms
      speechSplitInterval: 2000, //ms
      speechClearInterval: 360000, //ms
      recognitionOverInterval_H: "00", //hour
      recognitionOverInterval_M: "20", //minute
      recognitionOverInterval_S: "00", //second
      translationCount: 2,
      languages: ['ja', 'en', 'zh-TW'],
      azureVoices: ['ja-JP-AoiNeural', 'en-US-AnaNeural', 'zh-CN-XiaoyouNeural'],
      toggleButtonsClickedList: [],
      historyTextsMaxLength: 50,
      historyTextsCurrentId: 0,
      timestamp: -1,
    }
    var defaultTextConfig = {
      historyTexts: [[...defaultConfig.texts], ],
      historyTextLanguages: [[...defaultConfig.languages], ],
      historyTextTimestamps: [-1, ],
      furiganaTexts: [defaultConfig.displayedTexts[0], ],
      furiganaTextPos: [0, ],
      englishIpaTexts: [defaultConfig.displayedTexts[1], ],
      englishIpaTextPos: [1, ],
      chinesePinyinTexts: [defaultConfig.displayedTexts[2], ],
      chinesePinyinTextPos: [2, ],
    };
    // defaultConfig.displayedTexts[0] = defaultConfig.texts[0];
    // defaultConfig.displayedTexts[1] = defaultConfig.texts[1];
    // defaultConfig.displayedTexts[2] = defaultConfig.texts[2];
    var configs = [
      {}, {}, {},
    ];
    var textConfig = {
      historyTexts: [],
      historyTextLanguages: [],
      historyTextTimestamps: [],
      furiganaTexts: [],
      furiganaTextPos: [],
      englishIpaTexts: [],
      englishIpaTextPos: [],
      chinesePinyinTexts: [],
      chinesePinyinTextPos: [],
    };
    var favTextConfig = {
      favoriteTexts: [],
      favoriteTextLanguages: [],
    }
    var autoSID = 0;
    configs[autoSID] = copyConfig(defaultConfig);
    var LOCAL_TEST;
    var DEBUG_MODE;
  </script>
  <title>Snowy Speech Translator</title>
</head>
<body>
  <svg width="100%" viewBox="0 0 800 100" display="none">
    <text class="svg-stroke-text svg-stroke-layer-C" name="strokeTitleName" x="50%" y="50%">
    </text>
    <text class="svg-stroke-text svg-stroke-layer-B" name="strokeTitleName" x="50%" y="50%">
    </text>
    <text class="svg-stroke-text svg-stroke-layer-A" name="strokeTitleName" x="50%" y="50%">
    </text>
    <text class="svg-stroke-text" name="strokeTitleName" x="50%" y="50%">
    </text>
  </svg>

  <script>
    strokeTitles = document.querySelectorAll('.svg-stroke-text[name="strokeTitleName"]');
      strokeTitles.forEach(function(element) {
        element.textContent = "My Speech Translator";
    });
  </script>

  <iframe id="jpExpWebTop" style="width:1050px; height:654px; margin-top:5px; margin-bottom:5px; display:none" src="https://ichi.moe/"></iframe>

  <div id="speechTextArea">
    <div id="textMargin-0"> </div>
    <div style="position:relative;">
      <div class="stroke-text" id="displayedText-0"> </div>
      <div class="stroke-text-before" id="displayedStrokeText_0_0"> </div>
      <div class="stroke-text-after" id="displayedStrokeText_0_1"> </div>
    </div>

    <div id="textMargin-1"> </div>
    <div style="position:relative;">
      <div class="stroke-text" id="displayedText-1"> </div>
      <div class="stroke-text-before" id="displayedStrokeText_1_0"> </div>
      <div class="stroke-text-after" id="displayedStrokeText_1_1"> </div>
    </div>

    <div id="textMargin-2"> </div>
    <div style="position:relative;">
      <div class="stroke-text" id="displayedText-2"> </div>
      <div class="stroke-text-before" id="displayedStrokeText_2_0"> </div>
      <div class="stroke-text-after" id="displayedStrokeText_2_1"> </div>
    </div>

    <div id="textMarginBottom"> </div>

    <div id="emojiArea" style="position: absolute; bottom: 16px;">
      <div id="emojiText"> </div>
    </div>
  </div>

  <div class="hiddenTexts" style="display:none">
    <div id="text-0"> </div>
    <div id="text-1"> </div>
    <div id="text-2"> </div>
  </div>
  <script>
    // $(document).ready()
    $(function() {
      $('#speechTextArea').resizable({
        touchAction: 'none',
        handles: 'se',
        resize: function(event, ui) {
          updateCurtainHeight(ui.size.height);
          updateCurtainWidth(ui.size.width);
        }
      });
    });
  </script>

  <script>
    async function ggSpeakAllScreenText(repeatTime=1) {
      ggAudioListTmp = [];
      await addToGgReadingList(ggAudioListTmp, 3);
      await ggSpeakReadingList(ggAudioListTmp, repeatTime);
    }
    async function msSpeakAllScreenText(repeatTime=1) {
      msAudioListTmp = [];
      await addToMsReadingList(msAudioListTmp, 3);
      await msSpeakReadingList(msAudioListTmp, repeatTime);
    }
    async function ggSpeakAllInputText(text, languageSelect, isAutoDetect, repeatTime) {
      if (ggAudioList.length === 0) {
        if (text != texts[0].textContent) {
          console.log("❎ ggSpeakAllInputText() text != texts[0].textContent");
          await speechTranslate(text, languageSelect.value, isAutoDetect, languageSelect);
        }
        await addToGgReadingList(ggAudioList, 3);
      }
      await ggSpeakReadingList(ggAudioList, repeatTime);
    }
    async function msSpeakAllInputText(text, languageSelect, isAutoDetect, repeatTime) {
      if (msAudioList.length === 0) {
        if (text != texts[0].textContent) {
          console.log("❎ msSpeakAllInputText() text != texts[0].textContent");
          await speechTranslate(text, languageSelect.value, isAutoDetect, languageSelect);
        }
        await addToMsReadingList(msAudioList, 3);
      }
      await msSpeakReadingList(msAudioList, repeatTime);
    }
  </script>

  <div class="row-container" style="margin-top:10px; margin-bottom:5px;">
    <span style="display:flex; justify-content: center; margin-bottom:5px;">
      <button id="textFuriganaToggleButton" style="font-size: 11px; width:18px; display: flex; justify-content: center;" title="🔰 To Auto Mark Furigana; 💤 Is Off." onclick="toggleTextFurigana()">🔰</button>
      <button id="textEnglishIpaToggleButton" style="font-size: 11px; width:18px; display: flex; justify-content: center; margin-left:3px;" title="🌱 To Auto Mark English IPA; 🍂 Is Off." onclick="toggleEnglishIpa()">🍂</button>
      <button id="textChinesePinyinToggleButton" style="font-size: 11px; width:18px; display: flex; justify-content: center; margin-left:3px;" title="🌇 To Auto Mark Chinese Pinyin; 🌃 Is Off." onclick="toggleChinesePinyin()">🌃</button>
      <button id="textChatgptEmojiToggleButton" style="font-size: 11px; width:18px; display: flex; justify-content: center; margin-left:3px;" title="🥰 To Translate to emojis from chatGPT; 😐 Is Off." onclick="toggleEmojiText()">😐</button>

      <span style="margin-left:5px;"> </span>

      <button id="showFuriganaButton" style="font-size: 7px; width:22px; display: flex; justify-content: center; margin-left:3px;" title="Click 🍥 To Show Japanese Furigana; [ShortKey->1st Line: Ctrl + Alt + 1]" onclick="showFurigana()">🍥Jp</button>
      <button id="showEnglishIpaButton" style="font-size: 7px; width:22px; display: flex; justify-content: center; margin-left:3px;" title="Click 🍼 To Show English IPA; [ShortKey->2nd Line: Ctrl + Alt + 2]" onclick="showEnglishIpa()">🍼En</button>
      <button id="showChinesePinyinButton" style="font-size: 7px; width:22px; display: flex; justify-content: center; margin-left:3px;" title="Click 🐣 To Show Chinese Pinyin; [ShortKey->3rd Line: Ctrl + Alt + 3]" onclick="showChinesePinyin()">🐣Cn</button>
      <button id="showChatGptEmojiButton" style="font-size: 7px; width:22px; display: flex; justify-content: center; margin-left:3px;" title="Click 🥳 To Show ChatGPT Emoji; [ShortKey->3rd Line: Ctrl + Alt + 4]" onclick="showChatGptEmoji()">🥳Emj</button>
      <button style="font-size:11px; margin-left:3px;" title="Read All Screen Text By Google. [ShortKey: Shift + G]" onclick="ggSpeakAllScreenText()">G</button>
      <button style="font-size:11px; margin-left:3px;" title="Read All Screen Text By Microsoft. [ShortKey: Shift + M]" onclick="msSpeakAllScreenText()">M</button>
    </span>
    <span class="phone-new_line" style="display:none"><br></span>
    <span style="display:flex; justify-content: center; margin-bottom:5px;">
      <span style="margin-left:4px;"> </span>
      <button id="ggPauseAudio-button" style="font-size:9px; width:38px; margin-left:3px; vertical-align: middle;" onclick="ggPauseAudio()">G⏯</button>
      <button id="msPauseAudio-button" style="font-size:9px; width:38px; margin-left:3px; vertical-align: middle;" onclick="msPauseAudio()">M⏯</button>
      <span style="margin-left:7px;"> </span>
      <button style="font-size:10px;" title="Copy text of the source language. [ShortKey: Ctrl + Shift + 1; 'Ctrl+Shift + 4' for copy all]" onclick="copyText(0)">0</button>
      <button style="font-size:10px;" title="Copy text of the target1 language. [ShortKey: Ctrl + Shift + 2; 'Ctrl+Shift + 5' for copy all]" onclick="copyText(1)">1</button>
      <button style="font-size:10px;" title="Copy text of the target2 language. [ShortKey: Ctrl + Shift + 3; 'Ctrl+Shift + 6' for copy all]" onclick="copyText(2)">2</button>
      <span style="margin-left:7px;"> </span>
      <button id="previousText-button" title="Previous Texts; [ShortKey: Ctrl + LeftArrow]" onclick="showHistoryText(configs[autoSID].historyTextsCurrentId-1);">◀️</button>
      <button id="historyTextsIdDisplay" style="font-size:10px;" title="Add to favorite Texts" onclick="addToFavoriteListFromScreenText()"> X/X </button>
      <button id="nextText-button" title="Next Texts; [ShortKey: Ctrl + RightArrow]" onclick="showHistoryText(configs[autoSID].historyTextsCurrentId+1);">▶️</button>
    </span>
    <span class="reading-buttons-container" style="display:flex; justify-content: center; margin-bottom:5px;">
      <span class="reading-button-container" style="margin-left:16px;">
        <select id="displayedTextLanguageSelect0">
          <option value="ja" selected>🇯🇵</option>
          <option value="en">🇺🇸</option>
          <option value="zh-TW">🇹🇼</option>
        </select>
        <button title="Read First Language Text By Google." onclick="ggSpeak(texts[0].textContent, this.previousElementSibling.value)">G</button>
        <button title="Read First Language Text By Microsoft. [ShortKey: Shift + 1]" onclick="msSpeak(texts[0].textContent, this.previousElementSibling.previousElementSibling.value)">M</button>
      </span>
      <span class="reading-button-container" style="margin-left:8px;">
        <select id="displayedTextLanguageSelect1">
          <option value="ja">🇯🇵</option>
          <option value="en" selected>🇺🇸</option>
          <option value="zh-TW">🇹🇼</option>
        </select>
        <button title="Read Second Language Text By Google." onclick="ggSpeak(texts[1].textContent, this.previousElementSibling.value)">G</button>
        <button title="Read Second Language Text By Microsoft. [ShortKey: Shift + 2]" onclick="msSpeak(texts[1].textContent, this.previousElementSibling.previousElementSibling.value)">M</button>
      </span>
      <span class="reading-button-container" style="margin-left:8px;">
        <select id="displayedTextLanguageSelect2">
          <option value="ja">🇯🇵</option>
          <option value="en">🇺🇸</option>
          <option value="zh-TW" selected>🇹🇼</option>
        </select>
        <button title="Read Third Language Text By Google." onclick="ggSpeak(texts[2].textContent, this.previousElementSibling.value)">G</button>
        <button title="Read Third Language Text By Microsoft. [ShortKey: Shift + 3]" onclick="msSpeak(texts[2].textContent, this.previousElementSibling.previousElementSibling.value)">M</button>
        <span style="margin-left:4px;"> </span>
        <button class="phone-invisible" style="font-size: 10px; height:21px; vertical-align: middle;" title="Update Japanese Explaination Above. [ShortKey: Ctrl + UpArrow]" onclick="turnOnJpExpWebTop()">🍓</button>
        <button class="phone-invisible" style="font-size: 10px; height:21px; vertical-align: middle;" title="Copy Japanese Text With Furigana." onclick="CopyRubyText()">🎏</button>
        <button class="phone-invisible" id="captureAndSaveImageButton" style="font-size: 10px; height:21px; width:28px; vertical-align: middle;" title="Capture and Save as Image." onclick="captureAndSaveImage()">📸</button>
      </span>
    </span>
  </div>

  <table class="input-table">
    <tr class="input-table-row" id="recognitionInputArea" style="display:block">
      <td class="button-title">
        <span>
          <button id="recognize-button" title="[ShortKey: 'Shift + J' for switch to Japanease; 'Shift + E' for switch to English; 'Shift + T' for switch to Taiwanese]" onclick="toggleRecognition(this.parentNode.parentNode.querySelector('select').value)" style="width: 128px; font-size:10px;" >▶️ Start Recognizing</button>
            <select id="recognitionLanguageSelect" onchange="recognizeChange(this.value)">
              <option value="ja" selected>🇯🇵</option>
              <option value="en">🇺🇸</option>
              <option value="zh-TW">🇹🇼</option>
            </select>
            <button name="languageDetectButton" id="recognizeLangDetectToggleButton" title="🤔 To Auto Detect Text Language; 😴 Is Off." onclick="toggleAutoLangaugeDetect(this)">🤔</button>
            <button id="oneSentenceRecognizeToggleButton" title="① To Recognize A Single Sentence; 〜 Is Nonstop Detection." onclick="toggleOneSentenceRecognize(this)">①</button>
            <button id="updateHistoryTextToggleButton" title="🕳️ To Not Push to History Text; 🎈 Is To Push." onclick="toggleUpdateHistoryText(this)">🎈</button>
        </span>
        <button class="phone-only" onclick="toggleWidgetArea('recognitionInputArea', document.getElementById('toggleRecognitionInputArea_LayoutButton'))">⛔</button>
      </td>
      <td>
        <textarea id="recognitionResult" rows="2" cols="65"></textarea>
        <div style="display:none">
        <textarea id="recognitionPreviousResult" rows="2" cols="75"></textarea>
        </div>
      </td>
      <td>
        <button name="translateButton" title="Translate For Textarea." onclick="speechTranslate(this.parentNode.parentNode.querySelector('textarea').value, this.parentNode.parentNode.querySelector('select').value, this.parentNode.parentNode.querySelector('button[name=\'languageDetectButton\']').innerHTML === '🤔', recognitionLanguageSelect)">🔤</button>
        <button title="Copy From Textarea." onclick="copyTextArea(this)">📑</button>
        <button class="phone-only" onclick="pasteToTextArea(this)">📥</button>
        <button title="Clear Textarea." onclick="clearTextArea(this)">🆑</button>
        <span class="readButtonContainer">
          <button onclick="ggSpeak(this.parentNode.parentNode.parentNode.querySelector('textarea').value, this.parentNode.parentNode.parentNode.querySelector('select').value)">G🔊</button>
          <button onclick="msSpeak(this.parentNode.parentNode.parentNode.querySelector('textarea').value, this.parentNode.parentNode.parentNode.querySelector('select').value)">M🔊</button>
        </span>
      </td>
    </tr>

    <tr class="input-table-row" id="recordInputArea" style="display:none">
      <td class="button-title">
        <span>
          <button id="record-button" title="Record The Text Recognized." onclick="toggleRecord()" style="width: 128px; font-size:11px;" >▶️ Start Recording</button>
          <select id="recordLanguageSelect">
            <option value="ja" selected>🇯🇵</option>
            <option value="en">🇺🇸</option>
            <option value="zh-TW">🇹🇼</option>
          </select>
          <button name="languageDetectButton" id="recordLangDetectToggleButton" title="🤔 To Auto Detect Text Language; 😴 Is Off." onclick="toggleAutoLangaugeDetect(this)">🤔</button>
        </span>
        <button class="phone-only" onclick="toggleWidgetArea('recordInputArea', document.getElementById('toggleRecordInputArea_LayoutButton'))">⛔</button>
      </td>
      <td>
        <textarea id="recordResult" rows="2" cols="75"></textarea>
      </td>
      <td>
        <button name="translateButton" title="Translate For Textarea." onclick="speechTranslate(this.parentNode.parentNode.querySelector('textarea').value, this.parentNode.parentNode.querySelector('select').value, this.parentNode.parentNode.querySelector('button[name=\'languageDetectButton\']').innerHTML === '🤔', recordLanguageSelect)">🔤</button>
        <button title="Copy From Textarea." onclick="copyTextArea(this)">📑</button>
        <button title="Clear Textarea." onclick="clearTextArea(this)">🆑</button>
        <span class="readButtonContainer">
          <button onclick="ggSpeak(this.parentNode.parentNode.parentNode.querySelector('textarea').value, this.parentNode.parentNode.parentNode.querySelector('select').value)">G🔊</button>
          <button onclick="msSpeak(this.parentNode.parentNode.parentNode.querySelector('textarea').value, this.parentNode.parentNode.parentNode.querySelector('select').value)">M🔊</button>
        </span>
      </td>
    </tr>

    <tr class="input-table-row" id="translationInputArea" style="display:none">
      <td class="button-title">
        <span>
          <button onclick="speechTranslate(this.parentNode.parentNode.parentNode.querySelector('textarea').value, this.parentNode.parentNode.querySelector('select').value, querySelector('button[name=\'languageDetectButton\']').innerHTML === '🤔', translationLanguageSelect)" style="width: 128px; font-size:11px;"> Translate </button>
          <select id="translationLanguageSelect">
            <option value="ja">🇯🇵</option>
            <option value="en" selected>🇺🇸</option>
            <option value="zh-TW">🇹🇼</option>
          </select>
          <button name="languageDetectButton" id="translateLangDetectToggleButton" title="🤔 To Auto Detect Text Language; 😴 Is Off." onclick="toggleAutoLangaugeDetect(this)">🤔</button>
        </span>
        <button class="phone-only" onclick="toggleWidgetArea('translationInputArea', document.getElementById('toggleTranslationInputArea_LayoutButton'))">⛔</button>
      </td>
      <td>
        <textarea id="translateInput" rows="2" cols="75"></textarea>
      </td>
      <td>
        <button name="translateButton" title="Translate For Textarea."
          onclick="speechTranslate(this.parentNode.parentNode.querySelector('textarea').value, this.parentNode.parentNode.querySelector('select').value, this.parentNode.parentNode.querySelector('button[name=\'languageDetectButton\']').innerHTML === '🤔', translationLanguageSelect)">🔤</button>
        <button title="Copy From Textarea." onclick="copyTextArea(this)">📑</button>
        <button title="Clear Textarea." onclick="clearTextArea(this)">🆑</button>
        <span class="readButtonContainer">
          <button onclick="ggSpeak(this.parentNode.parentNode.parentNode.querySelector('textarea').value, this.parentNode.parentNode.parentNode.querySelector('select').value)">G🔊</button>
          <button onclick="msSpeak(this.parentNode.parentNode.parentNode.querySelector('textarea').value, this.parentNode.parentNode.parentNode.querySelector('select').value)">M🔊</button>
        </span>
      </td>
    </tr>

    <tr class="input-table-row" id="jpExpInputArea" style="display:none">
      <td class="button-title">
        <span>
          <button id="jpExp-button" onclick="furiganaFetchSplittedFromMyServer()" style="width: 128px; font-size:11px;">Japanese Explain</button>
          <select id="jpExpLanguageSelect">
            <option value="ja" selected>🇯🇵</option>
          </select>
        </span>
        <button class="phone-only" onclick="toggleWidgetArea('jpExpInputArea', document.getElementById('toggleJpExpInputArea_LayoutButton'))">⛔</button>
      </td>
      <td>
        <textarea id="jpExpInput" rows="2" cols="80"></textarea>
      </td>
      <td>
        <button name="translateButton" title="Translate For Textarea." onclick="speechTranslate(this.parentNode.parentNode.querySelector('textarea').value, 'ja')">🔤</button>
        <button title="Copy From Textarea." onclick="copyTextArea(this)">📑</button>
        <button title="Clear Textarea." onclick="clearTextArea(this)">🆑</button>
        <span class="readButtonContainer">
          <button  onclick="ggSpeak(this.parentNode.parentNode.parentNode.querySelector('textarea').value, this.parentNode.parentNode.parentNode.querySelector('select').value)">G🔊</button>
          <button onclick="msSpeak(this.parentNode.parentNode.parentNode.querySelector('textarea').value, this.parentNode.parentNode.parentNode.querySelector('select').value)">M🔊</button>
        </span>
      </td>
    </tr>
    <tr class="input-table-row" id="readingListInputArea" style="display:block">
      <td class="button-title">
        <span>
          <button name="translateButton" title="Translate For Textarea." onclick="speechTranslate(this.parentNode.parentNode.parentNode.querySelector('textarea').value, this.parentNode.parentNode.querySelector('select').value, this.parentNode.parentNode.querySelector('button[name=\'languageDetectButton\']').innerHTML === '🤔', translationLanguageSelect)">訳</button>
          <button onclick="addToReadingList(ggAudioList, msAudioList, 1)"> + </button>
          <button onclick="addToReadingList(ggAudioList, msAudioList, 2)"> ++ </button>
          <button onclick="addToReadingList(ggAudioList, msAudioList, 3)"> +++ </button>
          <select id="readingListLanguageSelect">
            <option value="ja" selected>🇯🇵</option>
            <option value="en">🇺🇸</option>
            <option value="zh-TW">🇹🇼</option>
          </select>
          <button name="languageDetectButton" id="readLangDetectToggleButton" title="🤔 To Auto Detect Text Language; 😴 Is Off." onclick="toggleAutoLangaugeDetect(this)">🤔</button>
        </span>
        <button class="phone-only" onclick="toggleWidgetArea('readingListInputArea', document.getElementById('toggleReadingListInputArea_LayoutButton'))">⛔</button>
      </td>
      <td>
        <textarea id="readingListInput" rows="2" cols="70"></textarea>
      </td>
      <td>
        <button name="translateButton" title="Translate For Textarea."
          onclick="speechTranslate(this.parentNode.parentNode.querySelector('textarea').value, this.parentNode.parentNode.querySelector('select').value, this.parentNode.parentNode.querySelector('button[name=\'languageDetectButton\']').innerHTML === '🤔', translationLanguageSelect)">🔤</button>
        <button title="Copy From Textarea." onclick="copyTextArea(this)">📑</button>
        <button class="phone-only" onclick="pasteToTextArea(this)">📥</button>
        <button title="Clear Textarea." onclick="clearTextArea(this)">🆑</button>
        <span class="readButtonContainer">
          <select id="repeatTimeSelect" style="width: 40px;">
            <option value=1>1</option>
            <option value=2 selected>2</option>
            <option value=3>3</option>
            <option value=5>5</option>
            <option value=10>10</option>
            <option value=20>20</option>
            <option value=30>30</option>
            <option value=50>50</option>
            <option value=99>99</option>
          </select>
          <button style="font-size: 7px;" onclick="ggSpeakAllInputText(this.parentNode.parentNode.parentNode.querySelector('textarea').value, this.parentNode.parentNode.parentNode.querySelector('select'), this.parentNode.parentNode.parentNode.querySelector('button[name=\'languageDetectButton\']').innerHTML === '🤔',  repeatTimeSelect.value)">G🔊</button>
          <button style="font-size: 7px;" onclick="msSpeakAllInputText(this.parentNode.parentNode.parentNode.querySelector('textarea').value, this.parentNode.parentNode.parentNode.querySelector('select'), this.parentNode.parentNode.parentNode.querySelector('button[name=\'languageDetectButton\']').innerHTML === '🤔',  repeatTimeSelect.value)">M🔊</button>
        </span>
      </td>
    </tr>
  </table>

  <div style="margin-top:6px; margin-bottom:6px;">
    <table style="border: 0px solid black; padding:10px;">
      <tr>
        <td>
          <span style="vertical-align: middle;">G</span>
          <audio id="ggSpeakAudio" src="static/Audio/あいうえお.mp3" controls style="height:25px; width:315px; vertical-align: middle; padding:1px;"></audio>
        </td>
        <td>
          <span style="vertical-align: middle;">M</span>
          <audio id="msSpeakAudio" src="static/Audio/abcdefg.mp3" controls style="height:25px; width:315px; vertical-align: middle; padding:1px;"></audio>
        </td>
      <tr>
    </table>
  </div>

  <div id="jpExpAreaFrame" style="display:none; margin-bottom:5px;">
    <div id="jpExpArea">
    </div>
  </div>
  <div id="jpExpAreaTest">
  </div>

  <iframe id="jpExpWebBot" style="width:1000px; height:654px; margin-top:5px; margin-bottom:9px; display:none" src="https://ichi.moe/"></iframe>

  <div>
    <button id="layoutContainer_LayoutButton" style="margin-bottom:5px;" onclick="toggleWidgetArea('layoutContainer', this)">Layout Container ❌</button>
    <button id="minimalistThemeButton" style="margin-bottom:5px;" onclick="minimalistTheme()">Minimalist Theme 🪟</button>
  </div>

  <div class="layouts-container" id="layoutContainer" style="margin-bottom:5px; display:none">
    <button id="toggleRecognitionInputArea_LayoutButton" style="margin-right:3px; margin-bottom:2px;" onclick="toggleWidgetArea('recognitionInputArea', this)">Recognition 🟢</button>
    <button id="toggleRecordInputArea_LayoutButton" style="margin-right:3px; margin-bottom:2px;" onclick="toggleWidgetArea('recordInputArea', this)">Record ❌</button>
    <button id="toggleTranslationInputArea_LayoutButton" style="margin-right:3px; margin-bottom:2px;" onclick="toggleWidgetArea('translationInputArea', this)">Translation ❌</button>
    <button id="toggleJpExpInputArea_LayoutButton" style="margin-right:3px; margin-bottom:2px;" onclick="toggleWidgetArea('jpExpInputArea', this)">JpExp Input ❌</button>
    <button id="toggleReadingListInputArea_LayoutButton" style="margin-right:3px; margin-bottom:2px;" onclick="toggleWidgetArea('readingListInputArea', this)">Reading Area 🟢</button>
    <button id="toggleJpExpArea_LayoutButton" style="margin-right:3px; margin-bottom:2px;" onclick="toggleWidgetArea('jpExpAreaFrame', this)">JpExp Text ❌</button>
    <button id="toggleJpExpWebTop_LayoutButton" style="margin-right:3px; margin-bottom:2px;" onclick="toggleJpExpWebTop()">JpExp Web (↑) ❌</button>
    <button id="toggleJpExpWebBot_LayoutButton" style="margin-right:3px; margin-bottom:2px;" onclick="toggleWidgetArea('jpExpWebBot', this)">JpExp Web (↓) ❌</button>
    <button id="toggleApiKeyEditor_LayoutButton" style="margin-right:3px; margin-bottom:2px;" onclick="toggleWidgetArea('apiKeyEditor', this)">ApiKey Editor ❌‍</button>
    <button id="toggleLayoutEditor_LayoutButton" style="margin-right:3px; margin-bottom:2px;" onclick="toggleWidgetArea('layoutEditor', this)">Layout Editor ❌</button>
    <button id="toggleLanguageSelects_LayoutButton" style="margin-right:3px; margin-bottom:2px;" onclick="toggleWidgetArea('languageSelectsContainer', this)">Lang Selects 🟢</button>
    <button id="toggleVoiceSelects_LayoutButton" style="margin-right:3px; margin-bottom:2px;" onclick="toggleWidgetArea('VoiceSelectsContainer', this)">Voice Selects 🟢</button>
    <button id="toggleGlobalValues_LayoutButton" style="margin-right:3px; margin-bottom:2px;" onclick="toggleWidgetArea('globalValuesContainer', this)">Global Values 🟢</button>
    <button class="phone-invisible" id="toggleAudioDownloadContainer_LayoutButton" style="margin-right:3px; margin-bottom:2px;" onclick="toggleWidgetArea('audioDownloadContainer', this)">Audio Download ❌</button>
    <button class="phone-invisible" id="toggleRubyConverter_LayoutButton" style="margin-right:3px; margin-bottom:2px;" onclick="toggleWidgetArea('rubyConverterContainer', this)">Ruby Converter ❌</button>
    <button id="toggleTextRecordArea_LayoutButton" style="margin-right:3px; margin-bottom:2px;" onclick="toggleWidgetArea('textRecordArea', this)">Text Record 🟢</button>
  </div>

  <script>
    const toggleButtonsMap = new Map();
    const toggleButtonsCountMap = new Map();
    const toggleButtonsClickedMap = new Map();

    function initLayoutButtons() {
      var layoutButtons = [];
      layoutButtons.push(...document.querySelectorAll('[id$="_LayoutButton"]'));
      layoutButtons.forEach(function(button) {
        var buttonText = button.innerHTML.substr(0, button.innerHTML.lastIndexOf(' '));
        toggleButtonsMap.set(buttonText, button);
        toggleButtonsCountMap.set(buttonText, 2);
        toggleButtonsClickedMap.set(buttonText, false);
      });
    };

    var toggleButtons = [];
    function initToggleButtons() {
      // console.log("🧮 toggleButtonsCountMap:", toggleButtonsCountMap);
      for (let buttonOptionCount = 2; buttonOptionCount <= 3; buttonOptionCount++) {
        if (buttonOptionCount === 2) toggleButtons = document.querySelectorAll(`button[id$="ToggleButton"]`);
        else toggleButtons = document.querySelectorAll(`button[id$="Toggle${buttonOptionCount}Button"]`);
        toggleButtons.forEach(button => {
          toggleButtonsMap.set(button.id, button);
          toggleButtonsCountMap.set(button.id, buttonOptionCount);
          toggleButtonsClickedMap.set(button.id, 0);
          button.addEventListener('click', () => {
            var buttonClickedCount = (toggleButtonsClickedMap.get(button.id) + 1) % buttonOptionCount;
            toggleButtonsClickedMap.set(button.id, buttonClickedCount);
            // another way to remove exsited buttons from the list
            // configs[autoSID].toggleButtonsClickedList = configs[autoSID].toggleButtonsClickedList.filter(item => item[0] !== button.id);
            let buttonInList = false;
            for (let i = 0; i < configs[autoSID].toggleButtonsClickedList.length; i++) {
              let pair = configs[autoSID].toggleButtonsClickedList[i];
              if (pair[0] === button.id) {
                pair[1] = buttonClickedCount;
                buttonInList = true;
                break;
              }
            }
            if (!buttonInList) {
              configs[autoSID].toggleButtonsClickedList.push([button.id, buttonClickedCount]);
            }
            saveConfigStorage();
          });
        });
      }
    }
  </script>


  <div id="layoutEditor" style="display:none; margin-top: 3px; margin-bottom: 3px;">
    <table style="margin-left: auto; margin-right: auto; margin-bottom: 3px;">
      <tr>
        <td>
          <span>Page Background Color:</span>
          <input id=pageColorPicker type="color" oninput="updatePageColor()">
          <span id="pageColorValue"></span>
        </td>
        <td>
          <span>Curtain Background Color:</span>
          <input id=curtainColorPicker type="color" oninput="updateCurtainColor()">
          <span id="curtainColorValue"></span>
        </td>
        <td>
          <button id="fixedHeightToggleButton" style="width:30px; height:22px; font-size:10px;" title="⚽️ Means Fixed Height With Auto Adjusted Font; 🏀 Means Auto Adjusted Height" onclick="toggleFixedHeight()">🏀</button>
          <button style="width:28px; height:22px; font-size:12px;" title="+ To add fonts sizes of each by 5" onclick="changeFontSizes(5)">+</button>
          <button style="width:28px; height:22px; font-size:12px;" title="- To substract fonts sizes of each by 5" onclick="changeFontSizes(-5)">-</button>
        </td>
      </tr>
    </table>
    <table style="margin-left: auto; margin-right: auto; margin-bottom: 3px;">
      <tr>
        <td>
          <button id="curtainLockToggleButton" style="width:28px; font-size:11px" title="🔐 To Lock The Curtain' Size Completely; 🔓 To Unlock." onclick="toggleCurtainLock()">🔓</button>
          <span>Curtain Height:</span>
          <input id=curtainHeightSlider type="range" min="50" max="1080" oninput="updateCurtainHeight()">
          <input type="number" id="curtainHeightValue" style="width: 50px;" oninput="updateCurtainHeight(curtainHeightValue.value)"> px
        </td>
        <td style="text-align: right;">
          <span>Curtain Width:</span>
          <input id=curtainWidthSlider type="range" min="200" max="1920" oninput="updateCurtainWidth()">
          <input type="number" id="curtainWidthValue" style="width: 50px;" oninput="updateCurtainWidth(curtainWidthValue.value)"> px
        </td>
        <td>
          <span>Margin To Bottom:</span>
          <input id=textMarginBottomSlider type="range" min="0" max="120" oninput="updateTextMarginBottom()">
          <span id="textMarginBottomValue"></span>px
        </td>
      </td>
    </table>

    <table>
      <tr>
        <td>
          <table class="phone-row-table">
            <tr>
              <th colspan="3"><span>Speech Text</span></th>
            </tr>
            <tr>
              <td><span>Text Color:</span></td>
              <td><input id=textColorPicker-0 type="color" oninput="updateFontColor(0)"></td>
              <td><span id="textColorValue-0"> </span></td>
            </tr>
            <tr>
              <td><span>Font Size: </span></td>
              <td><input id=textFontSizeSlider-0 type="range" min="1" max="99" step="1" oninput="updateFontSize(0)"></td>
              <td><span id="textFontSizeValue-0"></span>px</td>
            </tr>
            <tr>
              <td><span>Font Weight: </span></td>
              <td><input id="textFontWeightSlider-0" type="range" min="100" max="900" step="100" oninput=" updateFontWeight(0)"></td>
              <td><span id="textFontWeightValue-0"></span></td>
            </tr>
            <tr>
              <td><span>Font Type: </span></td>
              <td colspan="2"><select id="textFontSelect-0" onchange="updateFontFamily(0)">
              </select> </td>
            </tr>
            <tr>
              <td><span>Stroke Color (A):</span></td>
              <td><input id=textStrokeColorPicker-0-0 type="color" oninput="updateStrokeColor(0, 0)"></td>
              <td><span id="textStrokeColorValue-0-0"></span></td>
            </tr>
            <tr>
              <td><span>Stroke Width (A): </span></td>
              <td><input id="textStrokeWidthSlider-0-0" type="range" min="0" max="0.3" step="0.05" oninput="updateStrokeWidth(0, 0)"></td>
              <td><span id="textStrokeWidthValue-0-0"></span>em</td>
            </tr>
            <tr>
              <td><span>Stroke Color (B):</span></td>
              <td><input id=textStrokeColorPicker-0-1 type="color" oninput="updateStrokeColor(0, 1)"></td>
              <td><span id="textStrokeColorValue-0-1"></span></td>
            </tr>
            <tr>
              <td><span>Stroke Width (B): </span></td>
              <td><input id="textStrokeWidthSlider-0-1" type="range" min="0" max="0.8" step="0.05" oninput="updateStrokeWidth(0, 1)"></td>
              <td><span id="textStrokeWidthValue-0-1"></span>em</td>
            </tr>
            <tr>
              <td><label for="textShadowColorPicker-0">Shadow Color:</label></td>
              <td><input id=textShadowColorPicker-0 type="color" value="#DAFFFB" oninput="updateTextShadow(0)"></td>
              <td><span id="textShadowColorValue-0"> #DAFFFB </span></td>
            </tr>
            <tr>
              <td><span>Shadow Blur Radius: </span></td>
              <td><input id="textShadowBlurRadiusSlider-0" type="range" min="0" max="1" step="0.05" oninput="updateTextShadow(0)"></td>
              <td><span id="textShadowBlurRadiusValue-0"></span>em</td>
            </tr>
            <tr>
              <td><span>Margin To Top: </span></td>
              <td><input id="textMarginSlider-0" type="range" min="0" max="200" step="1" oninput="updateTextMargin(0)"></td>
              <td><span id="textMarginValue-0"></span>px</td>
            </tr>
          </table>
        </td>
        <td>
          <table class="phone-row-table">
            <tr>
              <th colspan="3"><span>Translation Text 1</span></th>
            </tr>
            <tr>
              <td><span>Text Color:</span></td>
              <td><input id=textColorPicker-1 type="color" oninput="updateFontColor(1)"></td>
              <td><span id="textColorValue-1"> </span></td>
            </tr>
            <tr>
              <td><span>Font Size: </span></td>
              <td><input id=textFontSizeSlider-1 type="range" min="1" max="99" step="1" oninput="updateFontSize(1)"></td>
              <td><span id="textFontSizeValue-1"></span>px</td>
            </tr>
            <tr>
              <td><span>Font Weight: </span></td>
              <td><input id="textFontWeightSlider-1" type="range" min="100" max="900" step="100" oninput=" updateFontWeight(1)"></td>
              <td><span id="textFontWeightValue-1"></span></td>
            </tr>
            <tr>
              <td><span>Font Type: </span></td>
              <td colspan="2"><select id="textFontSelect-1" onchange="updateFontFamily(1)">
              </select> </td>
            </tr>
            <tr>
              <td><span>Stroke Color (A):</span></td>
              <td><input id=textStrokeColorPicker-1-0 type="color" oninput="updateStrokeColor(1, 0)"></td>
              <td><span id="textStrokeColorValue-1-0"></span></td>
            </tr>
            <tr>
              <td><span>Stroke Width (A): </span></td>
              <td><input id="textStrokeWidthSlider-1-0" type="range" min="0" max="0.3" step="0.05" oninput="updateStrokeWidth(1, 0)"></td>
              <td><span id="textStrokeWidthValue-1-0"></span>em</td>
            </tr>
            <tr>
              <td><span>Stroke Color (B):</span></td>
              <td><input id=textStrokeColorPicker-1-1 type="color" oninput="updateStrokeColor(1, 1)"></td>
              <td><span id="textStrokeColorValue-1-1"></span></td>
            </tr>
            <tr>
              <td><span>Stroke Width (B): </span></td>
              <td><input id="textStrokeWidthSlider-1-1" type="range" min="0" max="0.8" step="0.05" oninput="updateStrokeWidth(1, 1)"></td>
              <td><span id="textStrokeWidthValue-1-1"></span>em</td>
            </tr>
            <tr>
              <td><label for="textShadowColorPicker-1">Shadow Color:</label></td>
              <td><input id=textShadowColorPicker-1 type="color" value="#DAFFFB" oninput="updateTextShadow(1)"></td>
              <td><span id="textShadowColorValue-1"> #DAFFFB </span></td>
            </tr>
            <tr>
              <td><span>Shadow Blur Radius: </span></td>
              <td><input id="textShadowBlurRadiusSlider-1" type="range" min="0" max="1" step="0.05" oninput="updateTextShadow(1)"></td>
              <td><span id="textShadowBlurRadiusValue-1"></span>em</td>
            </tr>
            <tr>
              <td><span>Margin To Top: </span></td>
              <td><input id="textMarginSlider-1" type="range" min="0" max="120" step="1" oninput="updateTextMargin(1)"></td>
              <td><span id="textMarginValue-1"></span>px</td>
            </tr>
          </table>
        </td>
        <td>
          <table class="phone-row-table">
            <tr>
              <th colspan="3"><span>Translation Text 2</span></th>
            </tr>
            <tr>
              <td><span>Text Color:</span></td>
              <td><input id=textColorPicker-2 type="color" oninput="updateFontColor(2)"></td>
              <td><span id="textColorValue-2"> </span></td>
            </tr>
            <tr>
              <td><span>Font Size: </span></td>
              <td><input id=textFontSizeSlider-2 type="range" min="1" max="99" step="1" oninput="updateFontSize(2)"></td>
              <td><span id="textFontSizeValue-2"></span>px</td>
            </tr>
            <tr>
              <td><span>Font Weight: </span></td>
              <td><input id="textFontWeightSlider-2" type="range" min="100" max="900" step="100" oninput=" updateFontWeight(2)"></td>
              <td><span id="textFontWeightValue-2"></span></td>
            </tr>
            <tr>
              <td><span>Font Type: </span></td>
              <td colspan="2"><select id="textFontSelect-2" onchange="updateFontFamily(2)">
              </select> </td>
            </tr>
            <tr>
              <td><span>Stroke Color (A):</span></td>
              <td><input id=textStrokeColorPicker-2-0 type="color" oninput="updateStrokeColor(2, 0)"></td>
              <td><span id="textStrokeColorValue-2-0"></span></td>
            </tr>
            <tr>
              <td><span>Stroke Width (A): </span></td>
              <td><input id="textStrokeWidthSlider-2-0" type="range" min="0" max="0.3" step="0.05" oninput="updateStrokeWidth(2, 0)"></td>
              <td><span id="textStrokeWidthValue-2-0"></span>em</td>
            </tr>
            <tr>
              <td><span>Stroke Color (B):</span></td>
              <td><input id=textStrokeColorPicker-2-1 type="color" oninput="updateStrokeColor(2, 1)"></td>
              <td><span id="textStrokeColorValue-2-1"></span></td>
            </tr>
            <tr>
              <td><span>Stroke Width (B): </span></td>
              <td><input id="textStrokeWidthSlider-2-1" type="range" min="0" max="0.8" step="0.05" oninput="updateStrokeWidth(2, 1)"></td>
              <td><span id="textStrokeWidthValue-2-1"></span>em</td>
            </tr>
            <tr>
              <td><label for="textShadowColorPicker-2">Shadow Color:</label></td>
              <td><input id=textShadowColorPicker-2 type="color" value="#DAFFFB" oninput="updateTextShadow(2)"></td>
              <td><span id="textShadowColorValue-2"> #DAFFFB </span></td>
            </tr>
            <tr>
              <td><span>Shadow Blur Radius: </span></td>
              <td><input id="textShadowBlurRadiusSlider-2" type="range" min="0" max="1" step="0.05" oninput="updateTextShadow(2)"></td>
              <td><span id="textShadowBlurRadiusValue-2"></span>em</td>
            </tr>
            <tr>
              <td><span>Margin To Top: </span></td>
              <td><input id="textMarginSlider-2" type="range" min="0" max="120" step="1" oninput="updateTextMargin(2)"></td>
              <td><span id="textMarginValue-2"></span>px</td>
            </tr>
          </table>
        </td>
      </tr>
    </table>
  </div>

  <table id="apiKeyEditor" style="display:none">
    <tr>
      <td style="width: 175px;"> Google Script API-KEY: </td>
      <td>
        <input type="password" id="apiKeyInput-0" size="50" placeholder="⚡ This api key is necessary to translate the speech text." oninput="updateApiKey(0)">
      </td>
      <td>
        <button ontouchstart="showApiKey(0, this)" ontouchend="hideApiKey(0, this)"
            onmousedown="showApiKey(0, this)" onmouseup="hideApiKey(0, this)">👁️</button> &nbsp;
        <button title="Copy From Textarea." onclick="copyApiKey(0, this)">📑</button>
      </td>
    </tr>
    <tr>
      <td style="width: 175px;"> GCP API-KEY: </td>
      <td>
        <input type="password" id="apiKeyInput-1" size="50" placeholder="🤔 This api key is to auto dect language better." oninput="updateApiKey(1)">
      </td>
      <td>
        <button ontouchstart="showApiKey(1, this)" ontouchend="hideApiKey(1, this)"
            onmousedown="showApiKey(1, this)" onmouseup="hideApiKey(1, this)">👁️</button> &nbsp;
        <button title="Copy From Textarea." onclick="copyApiKey(1, this)">📑</button>
      </td>
    </tr>
    <tr>
      <td style="width: 175px;"> Azure TTS Key: </td>
      <td>
        <input type="password" id="apiKeyInput-2" size="50" placeholder="🤖 This api key is to use Microsoft AI voice." oninput="updateApiKey(2)">
      </td>
      <td>
        <button ontouchstart="showApiKey(2, this)" ontouchend="hideApiKey(2, this)"
            onmousedown="showApiKey(2, this)" onmouseup="hideApiKey(2, this)">👁️</button> &nbsp;
        <button title="Copy From Textarea." onclick="copyApiKey(2, this)">📑</button>
      </td>
    </tr>
    <tr>
      <td style="width: 175px;"> ChatGPT Api Key: </td>
      <td>
        <input type="password" id="apiKeyInput-3" size="50" placeholder="🤖 This api key is to use the service of ChatGPT." oninput="updateApiKey(3)">
      </td>
      <td>
        <button ontouchstart="showApiKey(3, this)" ontouchend="hideApiKey(3, this)"
            onmousedown="showApiKey(3, this)" onmouseup="hideApiKey(3, this)">👁️</button> &nbsp;
        <button title="Copy From Textarea." onclick="copyApiKey(3, this)">📑</button>
      </td>
    </tr>
    <tr style="display:none;">
      <td style="width: 175px;"> Azure Translate Key: </td>
      <td>
        <input type="password" id="apiKeyInput-4" size="50" oninput="updateApiKey(4)">
      </td>
      <td>
        <button ontouchstart="showApiKey(4, this)" ontouchend="hideApiKey(4, this)"
            onmousedown="showApiKey(4, this)" onmouseup="hideApiKey(4, this)">👁️</button> &nbsp;
        <button title="Copy From Textarea." onclick="copyApiKey(4, this)">📑</button>
      </td>
    </tr>
    <tr>
      <td style="width: 175px;"> API Keys Split by ',': </td>
      <td>
        <input type="password" id="apiKeyInput-All" size="50" placeholder="📱 This blank is to fill the above three api keys once." oninput="updateApiKey(99, this.value)">
      </td>
    </tr>
  </table>

  <table style="border:none; margin-bottom:5px">
    <tr>
      <td>
      	<button id="defaultConfig-button" title="Recover To Default Configs." onclick="loadConfig(-1)">🆑</button>
      	<button id="saveConfig1-button" title="Save Configs[1]." onclick="saveConfig(1)">S1</button>
      	<button id="loadConfig1-button" title="Load Configs[1]" onclick="loadConfig(1)">L1</button>
      	<button id="saveConfig2-button" title="Save Configs[2]" onclick="saveConfig(2)">S2</button>
      	<button id="loadConfig2-button" title="Load Configs[2]" onclick="loadConfig(2)">L2</button>
        <span style="margin-left:5px;"> </span>
      	<button id="saveFavoriteConfig-button" title="Save Favorite Texts[♡]" style="display:none;" onclick="saveConfig(99)">S</button>
      	<button id="loadFavoriteConfig-button" title="Load Favorite Texts[♡]" style="display:none;" onclick="loadConfig(99)">L</button>
      </td>
      <td>
        <button id="clearText-button" title="Clear Texts 🆑" onclick="clearTexts();">Clear Texts</button>
        <button id="defaultText-button" title="Default Texts 🛠️" onclick="defaultTexts();">Default Texts</button>
        <button id="darkModeToggleButton" style="margin-left:5px;" onclick="toggleDarkMode()">🌞</button>
        <button id="specialLayoutToggle3Button" style="margin-left:5px;" onclick="toggleSpecialLayout()">🔄</button>
        <button id="fontSizeToggleButton" style="margin-left:5px;" title="👘 Means Bold Font; 👚 Means Thin Font" onclick="togglefontSize()">👘</button>
      </td>
    </tr>
  </table>

  <table id="languageSelectsContainer" style="margin-bottom:5px">
    <tr>
      <span style="display: inline-flex; width: 100%;">
        <td> Language To Recognize: </td>
        <td> <select id="languageSelect-0" onchange="updateLanguage(0)">
          <option value="en">English 英語 English</option>
          <option value="ja" selected>Japanese 日本語 日本語</option>
          <option value="zh-CN">Simplified Chinese 中国語 汉语</option>
          <option value="zh-TW">Traditional Chinese 台湾語 漢語</option>
          <option value="ko">Korean 韓国語 한국어</option>
          <option value="es">Spanish スペイン語 Español</option>
          <option value="fr">French フランス語 Français</option>
          <option value="pt">Portuguese ポルトガル語 Português</option>
          <option value="it">Italian イタリア語 Italiano</option>
          <option value="de">German ドイツ語 Deutsch</option>
          <option value="pl">Polish ポーランド語 Polski</option>
          <option value="nl">Dutch オランダ語 Nederlands</option>
          <option value="ru">Russian ロシア語 Русский</option>
          <option value="uk">Ukrainian ウクライナ語 українська</option>
        </select> </td>
      </span>
      <span style="display: inline-flex; width: 100%;">
        <td> Translation Counts: </td>
        <td> <select id="translationCountSelect" onchange="toggleTranslationCount()">
          <option value=0>No Translation</option>
          <option value=1>One Translation</option>
          <option value=2 selected>Two Translations</option>
        </select></td>
      </span>
    </tr>
    <tr>
      <td> Target Language 1: </td>
      <td> <select id="languageSelect-1" onchange="updateLanguage(1)">
        <option value="en" selected>English 英語 English</option>
        <option value="ja">Japanese 日本語 日本語</option>
        <option value="zh-CN">Simplified Chinese 中国語 汉语</option>
        <option value="zh-TW">Traditional Chinese 台湾語 漢語</option>
        <option value="ko">Korean 韓国語 한국어</option>
        <option value="es">Spanish スペイン語 Español</option>
        <option value="fr">French フランス語 Français</option>
        <option value="pt">Portuguese ポルトガル語 Português</option>
        <option value="it">Italian イタリア語 Italiano</option>
        <option value="de">German ドイツ語 Deutsch</option>
        <option value="pl">Polish ポーランド語 Polski</option>
        <option value="nl">Dutch オランダ語 Nederlands</option>
        <option value="ru">Russian ロシア語 Русский</option>
        <option value="uk">Ukrainian ウクライナ語 українська</option>
      </select> </td>
      <td>Target Language 2:</td>
      <td> <select id="languageSelect-2" onchange="updateLanguage(2)">
        <option value="en">English 英語 English</option>
        <option value="ja">Japanese 日本語 日本語</option>
        <option value="zh-CN">Simplified Chinese 中国語 汉语</option>
        <option value="zh-TW" selected>Traditional Chinese 台湾語 漢語</option>
        <option value="ko">Korean 韓国語 한국어</option>
        <option value="es">Spanish スペイン語 Español</option>
        <option value="fr">French フランス語 Français</option>
        <option value="pt">Portuguese ポルトガル語 Português</option>
        <option value="it">Italian イタリア語 Italiano</option>
        <option value="de">German ドイツ語 Deutsch</option>
        <option value="pl">Polish ポーランド語 Polski</option>
        <option value="nl">Dutch オランダ語 Nederlands</option>
        <option value="ru">Russian ロシア語 Русский</option>
        <option value="uk">Ukrainian ウクライナ語 українська</option>
      </select> </td>
    <tr>
  </table>

  <table id="VoiceSelectsContainer" style="margin-bottom:5px">
    <tr>
      <td> Azure Japanese Voice:
        <select id="azureVoiceSelect-Japanese" onchange="updateAzureVoice(0)">
          <option value="ja-JP-NanamiNeural">Nanami</option>
          <option value="ja-JP-KeitaNeural">Keita</option>
          <option value="ja-JP-AoiNeural">Aoi</option>
          <option value="ja-JP-DaichiNeural">Daichi</option>
          <option value="ja-JP-MayuNeural">Mayu</option>
          <option value="ja-JP-NaokiNeural">Naoki</option>
          <option value="ja-JP-ShioriNeural">Shiori</option>
        </select>
      </td>
      <td> Azure English Voice:
        <select id="azureVoiceSelect-English" onchange="updateAzureVoice(1)">
          <option value="en-US-JennyMultilingualNeural">Jenny Multilingual</option>
          <option value="en-US-JennyNeural">Jenny</option>
          <option value="en-US-GuyNeural">Guy</option>
          <option value="en-US-AriaNeural">Aria</option>
          <option value="en-US-DavisNeural">Davis</option>
          <option value="en-US-AmberNeural">Amber</option>
          <option value="en-US-AnaNeural">Ana</option>
          <option value="en-US-AshleyNeural">Ashley</option>
          <option value="en-US-BrandonNeural">Brandon</option>
          <option value="en-US-ChristopherNeural">Christopher</option>
          <option value="en-US-CoraNeural">Cora</option>
          <option value="en-US-ElizabethNeural">Elizabeth</option>
          <option value="en-US-EricNeural">Eric</option>
          <option value="en-US-JacobNeural">Jacob</option>
          <option value="en-US-JaneNeural">Jane</option>
          <option value="en-US-JasonNeural">Jason</option>
          <option value="en-US-JennyMultilingualV2Neural">Jenny Multilingual V2</option>
          <option value="en-US-MichelleNeural">Michelle</option>
          <option value="en-US-MonicaNeural">Monica</option>
          <option value="en-US-NancyNeural">Nancy</option>
          <option value="en-US-RogerNeural">Roger</option>
          <option value="en-US-RyanMultilingualNeural">Ryan Multilingual</option>
          <option value="en-US-SaraNeural">Sara</option>
          <option value="en-US-SteffanNeural">Steffan</option>
          <option value="en-US-TonyNeural">Tony</option>
          <option value="en-US-AIGenerate1Neural">AIGenerate1</option>
          <option value="en-US-AIGenerate2Neural">AIGenerate2</option>
          <option value="en-US-BlueNeural">Blue</option>
        </select>
      </td>
      <td> Azure Mandarin Voice:
        <select id="azureVoiceSelect-Chinese" onchange="updateAzureVoice(2)">
          <option value="zh-TW-HsiaoChenNeural">HsiaoChen</option>
          <option value="zh-TW-YunJheNeural">YunJhe</option>
          <option value="zh-TW-HsiaoYuNeural">HsiaoYu</option>
          <option value="zh-CN-XiaoxiaoNeural">Xiaoxiao</option>
          <option value="zh-CN-YunxiNeural">Yunxi</option>
          <option value="zh-CN-YunjianNeural">Yunjian</option>
          <option value="zh-CN-XiaoyiNeural">Xiaoyi</option>
          <option value="zh-CN-YunyangNeural">Yunyang</option>
          <option value="zh-CN-XiaochenNeural">Xiaochen</option>
          <option value="zh-CN-XiaohanNeural">Xiaohan</option>
          <option value="zh-CN-XiaomengNeural">Xiaomeng</option>
          <option value="zh-CN-XiaomoNeural">Xiaomo</option>
          <option value="zh-CN-XiaoqiuNeural">Xiaoqiu</option>
          <option value="zh-CN-XiaoruiNeural">Xiaorui</option>
          <option value="zh-CN-XiaoshuangNeural">Xiaoshuang</option>
          <option value="zh-CN-XiaoxuanNeural">Xiaoxuan</option>
          <option value="zh-CN-XiaoyanNeural">Xiaoyan</option>
          <option value="zh-CN-XiaoyouNeural">Xiaoyou</option>
          <option value="zh-CN-XiaozhenNeural">Xiaozhen</option>
          <option value="zh-CN-YunfengNeural">Yunfeng</option>
          <option value="zh-CN-YunhaoNeural">Yunhao</option>
          <option value="zh-CN-YunxiaNeural">Yunxia</option>
          <option value="zh-CN-YunyeNeural">Yunye</option>
          <option value="zh-CN-YunzeNeural">Yunze</option>
        </select>
      </td>
    <tr>
  </table>

  <table id="globalValuesContainer" style="margin-bottom:5px">
    <tr class="row-container">
      <td style="display: flex;">
        Speech Over Interval (ms):
        <input type="text" id="speechOverInterval" size="8" oninput="updateIntegerValue(this);">
      </td>
      <td style="display: flex;">
         History Texts Max Length:
        <select id="historyTextsMaxLengthSelect" style="width: 40px;" onchange="toggleHistoryTextsMaxLength()">
          <option value=1>1</option>
          <option value=2>2</option>
          <option value=3>3</option>
          <option value=5>5</option>
          <option value=10>10</option>
          <option value=20>20</option>
          <option value=30>30</option>
          <option value=50 selected>50</option>
          <option value=30>99</option>
        </select>
      </td>
      <td>
        Recognition Over Interval:
        <input type="number" id="recognitionOverInterval_H" maxlength="2" style="width: 18px;" oninput="updateTwoDigitsIntegerValue(this);"> h
        <input type="number" id="recognitionOverInterval_M" maxlength="2" style="width: 18px;" oninput="updateTwoDigitsIntegerValue(this);"> m
        <input type="number" id="recognitionOverInterval_S" maxlength="2" style="width: 18px;" oninput="updateTwoDigitsIntegerValue(this);"> s
        <button id="recognitionOverIntervalToggleButton" style="font-size: 11px;" title="▶️ To Start Recognition's Auto Stop Function; ⏹ Is Off." onclick="toggleRecognitionOverInterval()">⏹</button>
      </td>
      <td style="display: none;">
        Speech Split Interval (ms):
        <input type="text" id="speechSplitInterval" size="8" oninput="updateIntegerValue(this);">
      </td>
      <td style="display: none;">
        Speech Clear Interval (ms):
        <input type="text" id="speechClearInterval" size="8" oninput="updateIntegerValue(this);">
      </td>
    </tr>
  </table>

  <script>
    function getRandomInteger(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    function fillArrayWithRandomValue(arr, len, min, max) {
      var randomInteger = getRandomInteger(min, max);
      arr = Array.from({ length: len }, () => randomInteger);
      return arr;
    }
  </script>
  <script>
    var speechListTotalCount = 0;
    var isLastorder = false;
    function updateSpeechList(text) {
      if (!text) return;
      if (isLastorder) {
        if (speechList.lastElementChild && text === speechList.lastElementChild.textContent) return;
        var speechTextItem = document.createElement('li');
        speechTextItem.innerHTML = text;
        speechList.appendChild(speechTextItem);
        speechListTotalCount.innerHTML = `Total Count: ${speechList.childNodes.length}`;
      }
      else {
        if (speechList.firstElementChild && text === speechList.firstElementChild.textContent) return;
        var speechTextItem = document.createElement('li');
        speechTextItem.innerHTML = text;
        speechList.insertBefore(speechTextItem, speechList.firstElementChild);
        speechListTotalCount.innerHTML = `Total Count: ${speechList.childNodes.length}`;
      }
    }

    var texts = document.querySelectorAll('[id^="text-"]');
    var displayedTexts = document.querySelectorAll('[id^="displayedText-"]');
    var textColorPickers = document.querySelectorAll('[id^="textColorPicker-"]');
    var textColorValues = document.querySelectorAll('[id^="textColorValue-"]');
    var textFontSizeSliders = document.querySelectorAll('[id^="textFontSizeSlider-"]');
    var textFontSizeValues =  document.querySelectorAll('[id^="textFontSizeValue-"]');
    var textFontWeightSliders = document.querySelectorAll('[id^="textFontWeightSlider-"]');
    var textFontWeightValues = document.querySelectorAll('[id^="textFontWeightValue-"]');
    var textFontFamilySelects = document.querySelectorAll('[id^="textFontSelect-"]');
    var displayedTextLanguageSelects = document.querySelectorAll('[id^="displayedTextLanguageSelect"]');

    var timeTextUpdated = [-99, -99, -99];

    var textStrokeColorPickers = [];
    for (let i = 0; i < 3; i++) {
      textStrokeColorPickers[i] = [];
      for (let j = 0; j < 2; j++)
        textStrokeColorPickers[i][j] = document.getElementById(`textStrokeColorPicker-${i}-${j}`);
    }
    var textStrokeColorValues = [];
    var textStrokeWidthSliders = [];
    var textStrokeWidthValues = [];
    var strokeTexts = [];
    for (let i = 0; i < 3; i++) {
      textStrokeColorValues[i] = [];
      textStrokeWidthSliders[i] = [];
      textStrokeWidthValues[i] = [];
      strokeTexts[i] = [];
      // displayedTexts[i].style.zIndex = 3;
      for (let j = 0; j < 2; j++) {
        textStrokeColorValues[i][j] = document.getElementById(`textStrokeColorValue-${i}-${j}`);
        textStrokeWidthSliders[i][j] = document.getElementById(`textStrokeWidthSlider-${i}-${j}`);
        textStrokeWidthValues[i][j] = document.getElementById(`textStrokeWidthValue-${i}-${j}`);
        strokeTexts[i][j] = document.getElementById(`displayedStrokeText_${i}_${j}`);
      }
    }
    var textShadowColorPickers = document.querySelectorAll('[id^="textShadowColorPicker-"]');
    var textShadowColorValues = document.querySelectorAll('[id^="textShadowColorValue-"]');
    var textShadowBlurRadiusSliders = document.querySelectorAll('[id^="textShadowBlurRadiusSlider-"]');
    var textShadowBlurRadiusValues = document.querySelectorAll('[id^="textShadowBlurRadiusValue-"]');
    var textMarginSliders = document.querySelectorAll('[id^="textMarginSlider-"]');
    var textMarginValues = document.querySelectorAll('[id^="textMarginValue-"]');
    var textMargins = document.querySelectorAll('[id^="textMargin-"]');
    var apiKeyInputs = document.querySelectorAll('[id^="apiKeyInput-"]');
    var languageSelects = [];
    for (let i = 0; i <= topTranslationCount; i++) {
      languageSelects.push(document.getElementById(`languageSelect-${i}`));
    }
    var azureVoiceSelects = document.querySelectorAll('[id^="azureVoiceSelect-"]');

    var speechOverInterval_TimeOut;
    var speechSplitInterval_TimeOut;
    var speechClearInterval_TimeOut;

    var googleScriptKey;
    var gcpApiKey;
    var azureSpeechSubscriptionKey;
    var azureTranslateSubscriptionKey;
    var chatGptApiKey;

    function initSpecialLayoutButtons() {
      if (!googleScriptKey || googleScriptKey == "") {
        if (!apiKeyEditor || !apiKeyEditor.style.display || apiKeyEditor.style.display === 'none') {
          toggleApiKeyEditor_LayoutButton.click();
        }
        if (!layoutContainer || !layoutContainer.style.display || layoutContainer.style.display === 'none') {
          layoutContainer_LayoutButton.click();
        }
      }
      if (!googleScriptKey || googleScriptKey == "") {
        apiKeyEditor.style.backgroundColor = "#FFB8C6";
      }
      else {
        // apiKeyEditor.style.backgroundColor = document.body.style.backgroundColor;
      }
    }

    function updateToggleButtonClick(buttonText) {
      var button = toggleButtonsMap.get(buttonText);
      button.click();
    }
  </script>
  <script>
  const myLocalFonts = [
    'Seto',
    'Naikai',
    'Nishikiteki',
    'Iansui',
    'TaipeiSans',
    'BugMaruGothic',
    'WD-XLLubrifont',
    'tkFangSong',
    'LXGWWenKai',
    'LXGWWenKaiMono',
    'SourceHanSans',
    'SourceHanSerif',
    'XiaoheSimplifySans',
    'XiaoheSimplifySerif',
    'AdvocateAncientMono',
    'NotoSans',
    'NotoSansCJK',
    'NotoSansCJKjp',
    'KosugiMaru',
    'JF-openhuninn',
    '851MkPOP',
    'ChenYuluoyan',
    'KsoKagero',
    'KsoKaisho',
    'Mamelon',
    'OzCaramel',
    'Pigmo-00',
  ];
  const generateAllFontAreaCode = () => {
    textFontFamilySelects.forEach(function(element) {
      element.innerHTML = "";
      myLocalFonts.forEach(font => {
        element.innerHTML += `<option value="${font}">${font}</option>`;
      });
    });
  }
  </script>

  <script>
    function languageShortkey(language) {
      if (recognitionLanguageSelect.value === language) {
        if (isRecognizing) {
          stopRecognitionComplete(language);
        }
        else {
          startRecognition(language);
        }
      }
      else {
        recognitionLanguageSelect.value = language;
        if (isRecognizing) {
          recognizeRestart(sourceLanguage, language);
        }
      }
    }
    // https://css-tricks.com/snippets/javascript/javascript-keycodes/
    document.addEventListener("keydown", function(event) {
      if (event.ctrlKey && event.key === "ArrowLeft") {
        event.preventDefault();
        showHistoryText(configs[autoSID].historyTextsCurrentId-1);
      }
      else if (event.ctrlKey && event.key === "ArrowRight") {
        event.preventDefault();
        showHistoryText(configs[autoSID].historyTextsCurrentId+1);
      }
      else if (event.ctrlKey && event.key === "ArrowUp") {
        event.preventDefault();
        turnOnJpExpWebTop();
      }
      else if (event.ctrlKey && event.key === "ArrowDown") {
        event.preventDefault();
        captureAndSaveImage();
        allAudioDownload();
      }
      else if (event.ctrlKey && event.altKey && event.key === "1") {
        showRuby(0);
      }
      else if (event.ctrlKey && event.altKey && event.key === "2") {
        showRuby(1);
      }
      else if (event.ctrlKey && event.altKey && event.key === "3") {
        showRuby(2);
      }
      else if (event.ctrlKey && event.altKey && event.key === "4") {
        showChatGptEmoji();
      }
      else if (event.shiftKey && event.key === "P") {
        captureAndSaveImage();
      }
      else if (event.ctrlKey && event.shiftKey && event.key === "!") {
        event.preventDefault();
        copyText(0);
      }
      else if (event.ctrlKey && event.shiftKey && event.key === "@") {
        event.preventDefault();
        copyText(1);
      }
      else if (event.ctrlKey && event.shiftKey && event.key === "#") {
        event.preventDefault();
        copyText(2);
      }
      else if (event.ctrlKey && event.shiftKey && event.key === "$") {
        event.preventDefault();
        CopyRubyText(0);
      }
      else if (event.ctrlKey && event.shiftKey && event.key === "%") {
        event.preventDefault();
        CopyRubyText(1);
      }
      else if (event.ctrlKey && event.shiftKey && event.key === "^") {
        event.preventDefault();
        CopyRubyText(2);
      }
      else if (event.shiftKey && event.key === "J") {
        languageShortkey("ja");
      }
      else if (event.shiftKey && event.key === "E") {
        languageShortkey("en");
      }
      else if (event.shiftKey && event.key === "T") {
        languageShortkey("zh-TW");
      }
      else if (event.shiftKey && event.key === "<") {
        changeFontSizes(-5);
      }
      else if (event.shiftKey && event.key === ">") {
        changeFontSizes(5);
      }
      else if (event.shiftKey && event.key === "S") {
        toggleRecognition(recognitionLanguageSelect.value);
      }
      else if (event.shiftKey && event.key === "~") {
        toggleOneSentenceRecognize(oneSentenceRecognizeToggleButton);
      }
      else if (event.shiftKey && event.key === "G") {
        ggSpeakAllScreenText();
      }
      else if (event.shiftKey && event.key === "M") {
        msSpeakAllScreenText();
      }
      else if (event.shiftKey && event.key === "!") {
        msSpeak(texts[0].textContent, displayedTextLanguageSelect0.value);
      }
      else if (event.shiftKey && event.key === "@") {
        msSpeak(texts[1].textContent, displayedTextLanguageSelect1.value);
      }
      else if (event.shiftKey && event.key === "#") {
        msSpeak(texts[2].textContent, displayedTextLanguageSelect2.value);
      }
      else if (event.shiftKey && event.key === "A") {
        ggSpeakAudio.pause();
        msSpeakAudio.pause();
        // ggPauseAudio();
        // msPauseAudio();
      }
      else if (event.shiftKey && event.key === "O") { // Oo
        loadConfig(-1);
      }
    });
    document.addEventListener("keydown", async function(event) {
      if (event.shiftKey && event.key === "%") {
        msAudioListTmp = [];
        await addToMsReadingList(msAudioListTmp, 2);
        await msSpeakReadingList(msAudioListTmp, 1);
      }
    });

    function handleEnterKeyPress(textareaElement) {
      const buttonElement = textareaElement.parentNode.parentNode.querySelector('button[name="translateButton"]');
      textareaElement.addEventListener("keydown", function (event) {
        if (event.keyCode === 13 && event.shiftKey) {
          event.preventDefault();
          var textarea = event.target;
          var start = textarea.selectionStart;
          var end = textarea.selectionEnd;
          var value = textarea.value;
          textarea.value = value.substring(0, start) + "\n" + value.substring(end);
          textarea.selectionStart = textarea.selectionEnd = start + 1;
        }
        else if (event.keyCode === 13) {
          event.preventDefault();
          buttonElement.click();
        }
      });
    }
    handleEnterKeyPress(recognitionResult);
    handleEnterKeyPress(recordResult);
    handleEnterKeyPress(translateInput);
    handleEnterKeyPress(jpExpInput);
    handleEnterKeyPress(readingListInputArea);
  </script>

  <script>
    var recognizeButton = document.getElementById("recognize-button");
    var recordButton = document.getElementById("record-button");
    var isRecognizing = false;
    var isRecording = false;

    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    const recognition = new SpeechRecognition();

    var xmlRequest = new XMLHttpRequest();
    var requests = [];
    for (let i = 0; i < topTranslationCount; i++) {
      requests.push(new XMLHttpRequest());
    }

    function showApiKey(id, button) {
      apiKeyInputs[id].type = "text";
      button.innerHTML = "🤫";
    }
    function hideApiKey(id, button) {
      apiKeyInputs[id].type = "password";
      button.innerHTML = "👁️‍";
    }
    function copyApiKey(id, button) {
      var tempInput = document.createElement("input");
      tempInput.type = "text";
      tempInput.value = apiKeyInputs[id].value;
      document.body.appendChild(tempInput);
      tempInput.select();
      document.execCommand("copy");
      document.body.removeChild(tempInput);
    }
    function copyTextArea(button) {
      var textarea = button.parentNode.parentNode.querySelector('textarea');
      textarea.select();
      document.execCommand("copy");
    }
    function pasteToTextArea(button) {
      var textarea = button.parentNode.parentNode.querySelector('textarea');
      if (navigator.clipboard) {
        navigator.clipboard.readText()
          .then(text => {
              textarea.value = text;
          })
          .catch(err => {
              console.error('⚠️ Failed to read clipboard contents:', err);
          });
      }
    }
    function clearTextArea(button) {
      // nextElementSibling || previousElementSibling
      var textarea = button.parentNode.parentNode.querySelector('textarea');
      textarea.value = "";
    }
    function isPuntuation(character) {
      return /[.,!?;:—–(){}[\]“”‘’"'…・。、？！「」『』（）【】ー]/.test(character);
    }
    function isEnglishLetter(character) {
      return /^[A-Za-z]$/.test(character);
    }
    function addPunctuation(text) {
      if (!text) return "";
      var textTrim = text.trim();
      if (!textTrim) return "";
      var lastCharacter = textTrim[textTrim.length - 1];
      if (isPuntuation(lastCharacter)) return " " + text;
      if (isEnglishLetter(lastCharacter)) return " " + text + ". ";
      else return " " + text + "。 ";
    }
    function purifySpeechText(text) {
      text = text.replace(/[.,!?;:—–(){}\[\]“”‘’"'…・。、？！「」『』（）【】ー]/g, '');
      text = text.replace(/\s+/g, ' ');
      text = text.toLowerCase();
      return text;
    }
    function startRecognition(sourceLanguage="") {
      console.log("🧮 'webkitSpeechRecognition' in window:", 'webkitSpeechRecognition' in window);
      console.log("🧮 'SpeechRecognition' in window:", 'SpeechRecognition' in window);
      if ('webkitSpeechRecognition' in window) {
      } else if ('SpeechRecognition' in window) {
      } else {
        alert("🚨 Speech recognition is not supported in this browser.");
        stopRecognitionComplete(sourceLanguage);
      }
      if (!sourceLanguage) {
        sourceLanguage = languageSelects[0].value;
      }
      recognitionResult.value = "";
      recognitionPreviousResult.value = "";
      recognition.lang = sourceLanguage;
      recognition.interimResults = true;
      recognition.continuous = true;

      var recognitionTimestamp = 0;
      var isRecognizationSuspended = false;

      recognition.onstart = () => {
        console.log("onstart:", recognitionTimestamp);
        if (recognitionOverIntervalToggleButton.innerText === '⏹' && oneSentenceRecognizeToggleButton.innerHTML === '〜' && !isCountingDown) {
          recognitionCountdown();
        }
      }
      recognition.onaudiostart = () => {
        // console.log("onaudiostart:", recognitionTimestamp);
      }
      recognition.onsoundstart = () => {
        // console.log("onsoundstart:", recognitionTimestamp);
      }
      recognition.onspeechstart = () => {
        // console.log("onspeechstart:", recognitionTimestamp);
      }
      recognition.onspeechend = () => {
        // console.log("onspeechend:", recognitionTimestamp);
      }
      recognition.onsoundend = () => {
        // console.log("onsoundend:", recognitionTimestamp);
      }
      recognition.onaudioend = () => {
        // console.log("onaudioend:", recognitionTimestamp);
      }
      recognition.onend = () => {
        console.log("onend:", recognitionTimestamp);
        if (isRecognizing) {
          recognition.start();
          recognitionTimestamp = recognitionTimestamp + 1;
        }
      }
      recognition.onerror = () => {
        console.log("onerror:", recognitionTimestamp);
        recognition.stop();
      }
      recognition.onnomatch = () => {
        console.log("onnomatch:", recognitionTimestamp);
        recognition.stop();
      }
      stopRecognitionControl = function() {
        console.log(`🛑 recognition.stop() after speechSplitInterval(${speechSplitInterval.value}) turns to zero.`);
        recognition.stop();
      }
      recognition.onresult = function(event) {
        if (event.resultIndex + 1 < event.results.length) {
          console.log(`🔢 event.resultIndex = ${event.resultIndex}, event.results.length = ${event.results.length}`);
        }
        for (var i = event.resultIndex; i < event.results.length; i++) {
          var speechText = event.results[i][0].transcript;
          if (!speechText || !speechText.trim()) {
            console.log("⚪ Empty Speech Text.");
            continue;
          }
          var recognitionNonStop = oneSentenceRecognizeToggleButton.innerHTML === '〜';
          if (event.results[i].isFinal) {
            let purifiedSpeechText = purifySpeechText(speechText);
            speechText = addPunctuation(speechText);
            if (recognitionNonStop) {
              recognitionResult.value = speechText;
              console.log("✅🏁 Non Stop Final Text:", speechText);
              if (["英語変更", "英語 変更", "英語を変更", "英語に変更",
              "英語變更", "英文變更", "英语变更", "英文变更"].includes(purifiedSpeechText)) {
                recognitionLanguageSelect.value = "en";
                recognizeRestart(sourceLanguage, "en");
                return;
              }
              else if (["中国語変更", "中国語 変更", "中国語を変更", "中国語に変更",
              "mandarin switch", "mandarin recognize", "chinese switch", "chinese recognize"].includes(purifiedSpeechText)) {
                recognitionLanguageSelect.value = "zh-TW";
                recognizeRestart(sourceLanguage, "zh-TW");
                return;
              }
              else if (["日語變更", "日文變更", "日语变更", "日文变更",
              "japanese switch", "japanese recognize"].includes(purifiedSpeechText)) {
                recognitionLanguageSelect.value = "ja";
                recognizeRestart(sourceLanguage, "ja");
                return;
              }
              else if (["認識停止", "認識 停止", "recognition stop", "認知停止"
                      ].includes(purifiedSpeechText)) {
                speechTranslate(speechText, sourceLanguage, false, undefined, updateHistoryTextToggleButton.innerHTML === "🎈");
                stopRecognitionComplete(sourceLanguage);
                return;
              }
              else if (["認識一時停止", "認識 一時停止", "recognition suspended", "recognition pause", "認知暫停"].includes(purifiedSpeechText)) {
                speechTranslate(speechText, sourceLanguage, false, undefined, updateHistoryTextToggleButton.innerHTML === "🎈");
                isRecognizationSuspended = true;
                return;
              }
              else if (isRecognizationSuspended) {
                if (["続けて", "continue", "繼續"].includes(purifiedSpeechText)) {
                  isRecognizationSuspended = false;
                }
                else {
                  return;
                }
              }
              // recognitionResult.value = recognitionPreviousResult.value + addPunctuation(speechText);
              // recognitionPreviousResult.value = recognitionResult.value;
            }
            else { // One Sentence
              console.log("❌🏁 One Sentence Final Text:", speechText);
              recognitionResult.value = recognitionPreviousResult.value + speechText;
              recognitionPreviousResult.value = recognitionResult.value;
            }
            if (isRecording) {
              recordResult.value = recordResult.value + speechText;
            }
            // updateSpeechList(speechText);
            speechTranslate(speechText, sourceLanguage, false, undefined, updateHistoryTextToggleButton.innerHTML === "🎈"); // await
          }
          else if (!isRecognizationSuspended) { // Outcome of the process
            if (speechOverInterval.value && speechOverInterval.value !== 0) {
              if (!recognitionNonStop) {
                clearTimeout(speechOverInterval_TimeOut);
                speechOverInterval_TimeOut = setTimeout(function() {
                  stopRecognitionComplete(sourceLanguage);
                }, speechOverInterval.value);
                // console.log("❌↔️ One Sentence ↔️ Current Text:", speechText);
              }
              else { // One Sentence
                clearTimeout(speechSplitInterval_TimeOut);
                speechSplitInterval_TimeOut = setTimeout(stopRecognitionControl, speechSplitInterval.value);
                // console.log("✅↔️ Non Stop Current Text:", speechText);
              }
            }
            recognitionResult.value = recognitionPreviousResult.value + ' < ' + speechText + ' > ';
            // console.log("🚲 Current recognitionResult.value:", recognitionResult.value);
          }
        }
      };
      recognition.start();
      recognitionTimestamp = recognitionTimestamp + 1;
      isRecognizing = true;
      recognizeButton.innerHTML = "⏹ Stop Recognizing";
    }
    function stopRecognition() {
      if (recognition) {
        recognition.stop();
        console.log("🛑 stopRecognition(): isRecognizing => false");
      }
      isRecognizing = false;
      recognizeButton.innerHTML = "▶️ Start Recognizing";
      if (recognitionOverIntervalToggleButton.innerText === "⏹") {
        isCountingDown = false;
        clearInterval(recognitionCountdownInterval);
        recognitionOverInterval_H.value = configs[autoSID].recognitionOverInterval_H;
        recognitionOverInterval_M.value = configs[autoSID].recognitionOverInterval_M;
        recognitionOverInterval_S.value = configs[autoSID].recognitionOverInterval_S;
      }
    }
    function stopRecognitionComplete(sourceLanguage = "") {
      stopRecognition();
      if (sourceLanguage === "") {
        sourceLanguage = displayedTextLanguageSelect0.value;
      }
      if (false && isRecording) {
        isRecording = false;
        recordButton.innerHTML = "▶️ Start Recording";
      }
      if (recognitionResult.value !== texts[0].textContent) {
        updateSpeechList(recognitionResult.value);
        speechTranslate(recognitionResult.value, sourceLanguage, false, undefined, updateHistoryTextToggleButton.innerHTML === "🎈");
      }
    }
    function toggleRecognition(sourceLanguage, targetLanguage="") {
      if (targetLanguage === "") {
        targetLanguage = sourceLanguage;
      }
      if (isRecognizing) {
        stopRecognitionComplete(sourceLanguage);
      }
      else {
        startRecognition(targetLanguage);
        if (false && !isRecording) {
          isRecording = true;
          recordButton.innerHTML = "⏹ Stop Recording";
        }
      }
    }
    function recognizeChange(targetLanguage) {
      if (isRecognizing) {
        toggleRecognition(sourceLanguage, targetLanguage);
      }
    }
    function recognizeRestart(sourceLanguage, targetLanguage="") {
      if (targetLanguage === "") {
        targetLanguage = sourceLanguage;
      }
      toggleRecognition(sourceLanguage, targetLanguage);
      if (!isRecognizing) {
        setTimeout(function() {
          toggleRecognition(sourceLanguage, targetLanguage);
        }, 1200);
      }
    }
    function toggleRecord() {
      if (isRecording) {
        isRecording = false;
        recordButton.innerHTML = "▶️ Start Recording";
      }
      else {
        isRecording = true;
        recordButton.innerHTML = "⏹ Stop Recording";
      }
    }
    function toggleTextFurigana() {
      textFuriganaToggleButton.innerText = textFuriganaToggleButton.innerText === "🔰" ? "💤" : "🔰";
    }
    function toggleEnglishIpa() {
      textEnglishIpaToggleButton.innerText = textEnglishIpaToggleButton.innerText === "🌱" ? "🍂" : "🌱";
    }
    function toggleChinesePinyin() {
      textChinesePinyinToggleButton.innerText = textChinesePinyinToggleButton.innerText === "🌇" ? "🌃" : "🌇";
    }
    function toggleEmojiText() {
      textChatgptEmojiToggleButton.innerHTML = textChatgptEmojiToggleButton.innerText === "🥰" ? "😐" : "🥰";
    }

    function updateFuriganaText(japanesePosId, html, textTimestamp) {
      console.log("🎎 Try to updateFuriganaText()");
      updateRubyText(japanesePosId, html, textTimestamp);
      let htLength = textConfig.historyTexts.length;
      while (textConfig.furiganaTexts.length < htLength) {
        textConfig.furiganaTexts.push("");
        textConfig.furiganaTextPos.push(-1);
      }
      while (textConfig.furiganaTexts.length > htLength) {
        textConfig.furiganaTexts.shift();
        textConfig.furiganaTextPos.shift();
        console.log("💥 furiganaTexts.length > textConfig.historyTexts.length");
      }
      let historySearchRange = htLength > 10 ? 10 : htLength;
      for (let i = 1; i <= historySearchRange; i++) if (textTimestamp == textConfig.historyTextTimestamps[htLength - i]) {
        if (i > 1) {
          console.log("✨ Update FuriganaText To History List At Distance:", i);
        }
        textConfig.furiganaTexts[htLength - i] = html;
        textConfig.furiganaTextPos[htLength - i] = japanesePosId;
        break;
      }
      saveTextConfigStorage(autoSID);
    }
    function showFurigana() {
      let textTimestamp = textTimestampNow;
      for (let i = 0; i <= topTranslationCount; i++) if (displayedTextLanguageSelects[i].value === "ja") {
        var japanesePosId = i;
        console.log(`🔤 showFurigna(): pos=${japanesePosId}`);
        furiganaFetchFromMyServer(texts[japanesePosId].textContent)
        .then((html) => {
          updateFuriganaText(japanesePosId, html, textTimestamp);
        })
        .catch((error) => console.error(error));
      }
    }
    function updateEnglishIpaText(englishPosId, html, textTimestamp) {
      console.log("🔤 Try to updateEnglishIpaText()");

      if (textTimestamp == -123) {
        html = html.replace(/^<ruby>to<rt>(.*?)<\/rt>(<\/ruby>)/g, '<ruby>to$2');
        html = html.replace(/, <ruby>to<rt>(.*?)<\/rt>(<\/ruby>)/g, ', <ruby>to$2');
      }

      updateRubyText(englishPosId, html, textTimestamp);
      let htLength = textConfig.historyTexts.length;
      while (textConfig.englishIpaTexts.length < htLength) {
        textConfig.englishIpaTexts.push("");
        textConfig.englishIpaTextPos.push(-1);
      }
      while (textConfig.englishIpaTexts.length > htLength) {
        textConfig.englishIpaTexts.shift();
        textConfig.englishIpaTextPos.shift();
        console.log("💥 englishIpaTexts.length > textConfig.historyTexts.length");
      }
      let historySearchRange = htLength > 10 ? 10 : htLength;
      for (let i = 1; i <= historySearchRange; i++) if (textTimestamp == textConfig.historyTextTimestamps[htLength - i]) {
        if (i > 1) {
          console.log("✨ Update englishIpaText To History List At Distance:", i);
        }
        textConfig.englishIpaTexts[htLength - i] = html;
        textConfig.englishIpaTextPos[htLength - i] = englishPosId;
        break;
      }
      saveTextConfigStorage(autoSID);
    }
    var showEnglishIpaClickTimestamp = 0;
    var showEnglishIpaClickCooldownDuration = 8000;
    function showEnglishIpa() {
      let textTimestamp = textTimestampNow;
      var currentTime = new Date().getTime();
      if (currentTime - showEnglishIpaClickTimestamp >= showEnglishIpaClickCooldownDuration) {
        showEnglishIpaClickTimestamp = currentTime;
        showEnglishIpaButton.disabled = true;
        setTimeout(function() {
            showEnglishIpaButton.disabled = false;
        }, showEnglishIpaClickCooldownDuration);
      }
      else {
        console.log(`⏳ showEnglishIpa() Time not ready: ${currentTime - showEnglishIpaClickTimestamp} ms left`);
        return;
      }
      for (let i = 0; i <= topTranslationCount; i++) if (displayedTextLanguageSelects[i].value === "en") {
        var englishPosId = i;
        console.log(`🔤 showEnglishIpa(): pos=${englishPosId}`);
        englishIpaFetchFromMyServer(texts[englishPosId].textContent)
        .then((html) => {
          updateEnglishIpaText(englishPosId, html, textTimestamp);
        })
        .catch((error) => console.error(error));
      }
    }

    function updateChinesePinyinText(chinesePosId, html, textTimestamp) {
      console.log("🐼 Try to updateChinesePinyinText()");
      updateRubyText(chinesePosId, html, textTimestamp);
      let htLength = textConfig.historyTexts.length;
      while (textConfig.chinesePinyinTexts.length < htLength) {
        textConfig.chinesePinyinTexts.push("");
        textConfig.chinesePinyinTextPos.push(-1);
      }
      while (textConfig.chinesePinyinTexts.length > htLength) {
        textConfig.chinesePinyinTexts.shift();
        textConfig.chinesePinyinTextPos.shift();
        console.log("💥chinesePinyinTexts.length > textConfig.historyTexts.length");
      }
      let historySearchRange = htLength > 10 ? 10 : htLength;
      for (let i = 1; i <= historySearchRange; i++) if (textTimestamp == textConfig.historyTextTimestamps[htLength - i]) {
        if (i > 1) {
          console.log("✨ Update chinesePinyinText To History List At Distance:", i);
        }
        textConfig.chinesePinyinTexts[htLength - i] = html;
        textConfig.chinesePinyinTextPos[htLength - i] = chinesePosId;
        break;
      }
      saveTextConfigStorage(autoSID);
    }
    var showChinesePinyinClickTimestamp = 0;
    var showChinesePinyinClickCooldownDuration = 4000;
    function showChinesePinyin() {
      let textTimestamp = textTimestampNow;
      var currentTime = new Date().getTime();
      if (currentTime - showChinesePinyinClickTimestamp >= showChinesePinyinClickCooldownDuration) {
        showChinesePinyinClickTimestamp = currentTime;
        showChinesePinyinButton.disabled = true;
        setTimeout(function() {
            showChinesePinyinButton.disabled = false;
        }, showChinesePinyinClickCooldownDuration);
      }
      else {
        console.log(`⏳ showChinesePinyin() Time not ready: ${currentTime - showChinesePinyinClickTimestamp} ms left`);
        return;
      }
      for (let i = 0; i <= topTranslationCount; i++) if (displayedTextLanguageSelects[i].value === "zh-TW") {
        var chinesePosId = i;
        console.log(`🐼 showChinesePinyin(): pos=${chinesePosId}`);
        chinesePinyinFetchFromMyServer(texts[chinesePosId].textContent)
        .then((html) => {
          updateChinesePinyinText(chinesePosId, html, textTimestamp);
        })
        .catch((error) => console.error(error));
      }
    }

    var showChatGptEmojiClickTimestamp = 0;
    var showChatGptEmojiClickCooldownDuration = 4000;
    function showChatGptEmoji() {
      let textTimestamp = textTimestampNow;
      var currentTime = new Date().getTime();
      if (currentTime - showChatGptEmojiClickTimestamp >= showChatGptEmojiClickCooldownDuration) {
        showChatGptEmojiClickTimestamp = currentTime;
        showChatGptEmojiButton.disabled = true;
        setTimeout(function() {
            showChatGptEmojiButton.disabled = false;
        }, showChatGptEmojiClickCooldownDuration);
      }
      else {
        console.log(`⏳ showChatGptEmoji() Time not ready: ${currentTime - showChatGptEmojiClickTimestamp} ms left`);
        return;
      }
      console.log(`🥳 showChatGptEmoji()`);
      chatGptEmojiFetchFromMyServer(texts[0].textContent)
      .then((html) => {
        updateEmojiText(html, textTimestamp);
      })
      .catch((error) => console.error(error));
    }

    function showRuby(id) {
      if (displayedTextLanguageSelects[id].value === "ja") {
        showFurigana();
      }
      else if (displayedTextLanguageSelects[id].value === "en") {
        showEnglishIpa();
      }
      else if(displayedTextLanguageSelects[id].value === "zh-TW") {
        showChinesePinyin();
      }
    }

    function toggleTranslationCount(value=-1, clearBoolean=true) {
      if (value === -1) value = parseInt(translationCountSelect.value, 10);
      else translationCountSelect.value = value;
      translationCount = value;
      if (clearBoolean) {
        clearTexts(translationCount + 1);
        defaultTexts();
      }
      configs[autoSID].translationCount = parseInt(translationCountSelect.value, 10);
      saveConfigStorage();
    }

    /*
    var sourceLanguage = "ja";
    var targetLanguage = "en";
    function inputLanguageSwitch() {
      var button = document.getElementById("inputLanguageSwitch-button");
      if (sourceLanguage === "ja") {
        sourceLanguage = "en";
        targetLanguage = "ja";
        button.innerHTML = "EN🔤"
      } else {
        sourceLanguage = "ja";
        targetLanguage = "en";
        button.innerHTML = "JP🔤"
      }
    }
    */

    function toggleAutoLangaugeDetect(button) {
      button.innerText = button.innerText === "🤔" ? "😴" : "🤔";
    }
    function toggleOneSentenceRecognize(button) {
      button.innerText = button.innerText === "①" ? "〜" : "①";
    }
    function toggleUpdateHistoryText(button) {
      button.innerText = button.innerText === "🎈" ? "🕳️" : "🎈";
    }
    function toggleHistoryTextsMaxLength(value=-1) {
      if (value === -1) value = historyTextsMaxLengthSelect.value;
      else historyTextsMaxLengthSelect.value = value;
      configs[autoSID].historyTextsMaxLength = value;
      saveConfigStorage();
    }
    function JpExpWebTopLayoutAdjust() {
      console.log("📜 JpExpWebTopLayoutAdjust()");
      var splitPos = toggleJpExpWebTop_LayoutButton.innerHTML.lastIndexOf(' ');
      var trigger = toggleJpExpWebTop_LayoutButton.innerHTML.substr(splitPos + 1);
      if (trigger === "🟢") {
        // console.log("🍓JpExpWebTopLayoutAdjust()");
        setTimeout(() => {
          window.scrollTo(0, 674);
        }, 10);
      }
    }
    function toggleJpExpWebTop() {
      toggleWidgetArea('jpExpWebTop', toggleJpExpWebTop_LayoutButton);
      // JpExpWebTopLayoutAdjust();
    }
    function turnOnJpExpWebTop() {
      var splitPos = toggleJpExpWebTop_LayoutButton.innerHTML.lastIndexOf(' ');
      var trigger = toggleJpExpWebTop_LayoutButton.innerHTML.substr(splitPos + 1);
      if (trigger === "❌") {
        toggleJpExpWebTop();
      }
      jpExpWebUpdate(texts[languagePosIdMap["ja"]].textContent);
    }
    function CopyRubyText(languagePos=-1, justReturnText=false, completeCopy=-1) {
      if (languagePos === -1) {
        languagePos = languagePosIdMap["ja"];
      }
      var rubyText = displayedTexts[languagePos].innerHTML;
      rubyText = rubyConvert(rubyText, completeCopy);
      if (justReturnText) {
        return rubyText;
      }
      navigator.clipboard.writeText(rubyText);
      return "";
    }

    var recognitionCountdownInterval;
    var isCountingDown;
    function recognitionCountdown() {
      isCountingDown = true;
      let h = 0, m = 0, s = 0;
      if (recognitionOverInterval_H.value) h = parseInt(recognitionOverInterval_H.value, 10);
      if (recognitionOverInterval_M.value) m = parseInt(recognitionOverInterval_M.value, 10);
      if (recognitionOverInterval_S.value) s = parseInt(recognitionOverInterval_S.value, 10);
      recognitionCountdownInterval = setInterval(function() {
        if (h <= 0 && m <= 0 && s <= 0 || recognitionOverIntervalToggleButton.innerText === "▶️") {
          isCountingDown = false;
          clearInterval(recognitionCountdownInterval);
          if (isRecognizing) {
            stopRecognitionComplete();
            updateIntegerValue(recognitionOverInterval_H, configs[autoSID].recognitionOverInterval_H);
            updateIntegerValue(recognitionOverInterval_M, configs[autoSID].recognitionOverInterval_M);
            updateIntegerValue(recognitionOverInterval_S, configs[autoSID].recognitionOverInterval_S);
          }
        }
        else {
          s -= 1;
          if (s < 0) {
            s += 60; m -= 1;
            if (m < 0) {
              m += 60; h -= 1;
            }
          }
          recognitionOverInterval_H.value = String(h).padStart(2, "0");
          recognitionOverInterval_M.value = String(m).padStart(2, "0");
          recognitionOverInterval_S.value = String(s).padStart(2, "0");
        }
      }, 1000);
    }
    function toggleRecognitionOverInterval() {
      recognitionOverIntervalToggleButton.innerText = recognitionOverIntervalToggleButton.innerText === "▶️" ? "⏹" : "▶️";
      clearInterval(recognitionCountdownInterval);
      if (recognitionOverIntervalToggleButton.innerText === "⏹") {
        isCountingDown = false;
        let h = 0, m = 0, s = 0;
        if (recognitionOverInterval_H.value) h = parseInt(recognitionOverInterval_H.value, 10);
        if (recognitionOverInterval_M.value) m = parseInt(recognitionOverInterval_M.value, 10);
        if (recognitionOverInterval_S.value) s = parseInt(recognitionOverInterval_S.value, 10);
        m += Math.floor(s / 60); s %= 60;
        h += Math.floor(s / 60); m %= 60;
        recognitionOverInterval_H.value = String(h).padStart(2, "0");
        recognitionOverInterval_M.value = String(m).padStart(2, "0");
        recognitionOverInterval_S.value = String(s).padStart(2, "0");
        updateIntegerValue(recognitionOverInterval_H);
        updateIntegerValue(recognitionOverInterval_M);
        updateIntegerValue(recognitionOverInterval_S);
      }
    }
    function updateTwoDigitsIntegerValue(inputArea) {
      if (inputArea.value.length > 2) {
        inputArea.value = inputArea.value.slice(0, 2);
      }
      inputArea.value = String(inputArea.value).padStart(2, "0");
      updateIntegerValue(inputArea);
    }
    function getFormattedTime() {
      const date = new Date();
      const year = date.getFullYear().toString().slice(-2);
      const month = (date.getMonth() + 1).toString().padStart(2, '0');
      const day = date.getDate().toString().padStart(2, '0');
      const hours = date.getHours().toString().padStart(2, '0');
      const minutes = date.getMinutes().toString().padStart(2, '0');
      const seconds = date.getSeconds().toString().padStart(2, '0');
      const milliseconds = date.getMilliseconds().toString().substring(0, 2).padStart(2, '0');
      return `(${year}${month}${day}-${hours}${minutes}${seconds}-${milliseconds})`;
    }

    function sanitizeForWindowsFileName(inputString) {
      const illegalCharsRegex = /[\/:*?"|]/g;
      const sanitizedString = inputString.replace(illegalCharsRegex, "_");
      if (sanitizedString.trim() === "") { }
      const finalFileName = sanitizedString.trim()
        .replace(/^\.+|\.+$/g, "").replace(/<[^>]+>/g, '').replace(/[<>]/g, '');
      const maxLength = 100; // 255
      return finalFileName.substring(0, maxLength);
    }

    var ggAudioList = [];
    var msAudioList = [];
    var ggAudioListTmp = [];
    var msAudioListTmp = [];
    async function ggSpeakUrlGet(text, sourceLanguage) {
      if (window.location.protocol === "file:") {
        var ggTranslateUrl = "https://translate.google.com/translate_tts?ie=UTF-8&tl=" +
          sourceLanguage +  "&client=tw-ob&q=" + encodeURIComponent(text);
        return ggTranslateUrl;
      }
      else {
        try {
          const response = await fetch('https://snsmile.site:3000/text-to-speech', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              sourceLanguage: sourceLanguage,
              text: text
            })
          });
          if (!response.ok) {
            throw new Error('Network response was not ok');
          }
          const audioData = await response.arrayBuffer();
          const audioBlob = new Blob([audioData], { type: 'audio/mpeg' });
          return URL.createObjectURL(audioBlob);
        } catch (error) {
          console.error('Error:', error);
          return null; // or handle the error in a way appropriate for your application
        }
      }
    }
    async function ggSpeak(text, sourceLanguage = "") {
      console.log("🔊 ggSpeak text:", text);
      if (!text) return;
      if (sourceLanguage === "") {
        sourceLanguage = "ja";
      }
      if (ggSpeakAudio) {
        ggSpeakAudio.pause();
      }
      ggSpeakAudio.src = await ggSpeakUrlGet(text, sourceLanguage);
      ggSpeakAudio.play();

      /* if ("speechSynthesis" in window) { // Another AI Voice
        var speechSynthesis = window.speechSynthesis;
        var utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = sourceLanguage;
        speechSynthesis.speak(utterance);
      } */
    }

		const MSTTS_region = "southeastasia";
		const MSTTS_endpoint1 = `https://${MSTTS_region}.api.cognitive.microsoft.com/sts/v1.0/issuetoken`;
		const MSTTS_endpoint2 = `https://${MSTTS_region}.tts.speech.microsoft.com/cognitiveservices/v1`;
    var MSTTS_accessToken = "";
    function getMsttsAccessToken() {
      return new Promise((resolve, reject) => {
        var xhr1 = new XMLHttpRequest();
        xhr1.open('POST', MSTTS_endpoint1);
        xhr1.setRequestHeader('Ocp-Apim-Subscription-Key', azureSpeechSubscriptionKey);
        xhr1.send();
        xhr1.onreadystatechange = function() {
          if (xhr1.readyState === 4) {
            if (xhr1.status === 200) {
              MSTTS_accessToken = xhr1.responseText;
              resolve(MSTTS_accessToken);
            } else {
              reject(new Error(`Failed to get Azure Access Token. Status code: ${xhr1.status}`));
            }
          }
        };
        xhr1.onerror = function() {
          reject(new Error('Request error'));
        };
      });
    }
    async function getMsAudioData(text, sourceLanguage, voiceName) {
      return new Promise((resolve, reject) => {
        const xhr2 = new XMLHttpRequest();
        const headers = {
          "Authorization": `Bearer ${MSTTS_accessToken}`,
          "Content-Type": "application/ssml+xml",
          "X-Microsoft-OutputFormat": "audio-16khz-128kbitrate-mono-mp3"
        };
        xhr2.open('POST', MSTTS_endpoint2);
        for (const [key, value] of Object.entries(headers)) {
          xhr2.setRequestHeader(key, value);
        }
        xhr2.responseType = 'arraybuffer';
        const requestBody = `<speak version='1.0' xml:lang='en-US'><voice name='${voiceName}'>${text}</voice></speak>`;
        xhr2.onload = function() {
          if (xhr2.status >= 200 && xhr2.status < 300) {
            resolve(xhr2.response);
          } else {
            reject(new Error(`Request failed with status ${xhr2.status}`));
          }
        };
        xhr2.onerror = function() {
          reject(new Error('Request error'));
        };
        xhr2.send(requestBody);
      });
    }
    function updateAzureVoice(id, value="") {
      if (!value) value = azureVoiceSelects[id].value;
      else azureVoiceSelects[id].value = value;
      configs[autoSID].azureVoices[id] = value;
      saveConfigStorage();
    }
    async function msSpeak(text, sourceLanguage = "", voiceName = "") {
      console.log(`🔊 msSpeak-text: ${text}; sourceLanguage: ${sourceLanguage}; voiceName: ${voiceName}`);
      if (!text) return;
      if (!voiceName) {
        if (sourceLanguage === "ja") {
          voiceName = azureVoiceSelects[0].value;
        } else if (sourceLanguage === "en") {
          voiceName = azureVoiceSelects[1].value;
        } else if (sourceLanguage === "zh-TW") {
          voiceName = azureVoiceSelects[2].value;
        }
      }
      try {
        await getMsttsAccessToken();
        const audioData = await getMsAudioData(text, sourceLanguage, voiceName);
        const audioBlob = new Blob([audioData], { type: 'audio/mpeg' });
        msSpeakAudio.src = URL.createObjectURL(audioBlob);
        msSpeakAudio.play();
      } catch (error) {
        console.error("Error while executing msSpeak:", error);
      }
    }


    function msPauseAudio() {
      if (msSpeakAudio) {
        if (msSpeakAudio.paused) {
          msSpeakAudio.play();
        } else {
          msSpeakAudio.pause();
        }
      }
    }
    function ggPauseAudio() {
      if (ggSpeakAudio) {
        if (ggSpeakAudio.paused) {
          ggSpeakAudio.play();
        } else {
          ggSpeakAudio.pause();
        }
      }
    }

    function clearReadingList() {
      ggAudioList = [];
      msAudioList = [];
      while (readingList.firstChild) {
        readingList.removeChild(readingList.firstChild);
      }
    }
    function clearFavoriteList() {
      while (favoriteTable.firstChild) {
        favoriteTable.removeChild(favoriteTable.firstChild);
      }
      favTextConfig.favoriteTexts = [];
      favTextConfig.favoriteTextLanguages = [];
      saveFavoriteTextConfigStorage();
    }
    function clearSpeechList() {
      while (speechList.firstChild) {
        speechList.removeChild(speechList.firstChild);
      }
    }
    function chooseAzureVoice(sourceLanguage) {
      if (sourceLanguage === "ja") {
        return azureVoiceSelects[0].value;
      } else if (sourceLanguage === "en") {
        return azureVoiceSelects[1].value;
      } else if (sourceLanguage === "zh-TW") {
        return azureVoiceSelects[2].value;
      }
    }
    async function addToGgReadingList(ggAudioList, lines=1) {
      for (let i = 0; i < lines; i++) {
        var url = await ggSpeakUrlGet(texts[i].textContent, displayedTextLanguageSelects[i].value);
        ggAudioList.push(url);
      }
      console.log("🗃️ ggAudioList:", ggAudioList);
    }
    async function addToMsReadingList(msAudioList, lines = 1) {
      try {
        await getMsttsAccessToken();
        for (let i = 0; i < lines; i++) {
          var voiceName = chooseAzureVoice(displayedTextLanguageSelects[i].value);
          const audioData = await getMsAudioData(texts[i].textContent, displayedTextLanguageSelects[i].value, voiceName);
          msAudioList.push(audioData);
        }
        console.log("🗃️ msAudioList:", msAudioList);
        return msAudioList;
      } catch (error) {
        console.error("Error while adding to MsReadingList:", error);
        throw error;
      }
    }

    /*
      readingList
        itemContainer
          readingListItem, buttonContainer
    */
    async function addToReadingList(ggAudioList, msAudioList, lines=1) {
      await addToGgReadingList(ggAudioList, lines);
      await addToMsReadingList(msAudioList, lines);
      for (let i = 0; i < lines; i++) {

        let readingListItem = document.createElement('li');
        readingListItem.textContent = texts[i].textContent + ` - [${displayedTextLanguageSelects[i].value}]`;

        let ggSpeakReadingListItemButton = document.createElement('button');
        ggSpeakReadingListItemButton.textContent = 'G';
        let msSpeakReadingListItemButton = document.createElement('button');
        msSpeakReadingListItemButton.textContent = 'M';
        let removeReadingListItemButton = document.createElement('button');
        removeReadingListItemButton.style.fontSize = "11px";
        removeReadingListItemButton.textContent = '⛔';

        let buttonContainer =  document.createElement('span');
        buttonContainer.appendChild(ggSpeakReadingListItemButton);
        buttonContainer.appendChild(msSpeakReadingListItemButton);
        buttonContainer.appendChild(removeReadingListItemButton);

        let itemContainer = document.createElement('div');
        itemContainer.style.display = 'flex';
        itemContainer.style.justifyContent = 'space-between';
        itemContainer.appendChild(readingListItem);
        itemContainer.appendChild(buttonContainer);

        removeReadingListItemButton.addEventListener('click', function() {
          const index = Array.from(readingList.children).indexOf(itemContainer);
          ggAudioList.splice(index, 1);
          msAudioList.splice(index, 1);
          itemContainer.remove();
        });
        ggSpeakReadingListItemButton.addEventListener('click', function() {
          const index = Array.from(readingList.children).indexOf(itemContainer);
          ggSpeakSingleAudioOfList(index);
        });
        msSpeakReadingListItemButton.addEventListener('click', function() {
          const index = Array.from(readingList.children).indexOf(itemContainer);
          msSpeakSingleAudioOfList(index);
        });

        readingList.appendChild(itemContainer);
      }
    }
    function sentenceSplit(sentence) {
      var values = sentence.split(' - [');
      var text = values[0];
      var language = values[1].slice(0, -1);
      return [text, language];
    }
    function addToFavoriteListFromScreenText() {
      favTextConfig.favoriteTexts.push([...texts].map(element => element.textContent));
      favTextConfig.favoriteTextLanguages.push([...displayedTextLanguageSelects].map(element => element.value));
      while (favTextConfig.favoriteTexts.length > 150) {
        favTextConfig.favoriteTexts.shift();
        favTextConfig.favoriteTextLanguages.shift();
      }
      saveFavoriteTextConfigStorage();
      addToFavoriteList([...texts].map(element => element.textContent), [...displayedTextLanguageSelects].map(element => element.value), translationCount + 1);
    }
    function removeFromFavoriteTextConfig(index) {
      favTextConfig.favoriteTexts.splice(index, 1);
      favTextConfig.favoriteTextLanguages.splice(index, 1);
      saveFavoriteTextConfigStorage();
    }

    /*
    elementTr
      elementTd,    elementButtonTd
        favoriteTextItem0,  buttonContainer0, buttonContainer1, buttonContainer2
          elementUl
            elementLi1(favoriteTextItem1)
            elementLi2(favoriteTextItem2)
    */
    function addToFavoriteList(texts, langs, len) {
      console.log("⭐ addToFavoriteList");
      let elementTr = document.createElement('tr');
      favoriteTable.appendChild(elementTr);
      let elementTextTd = document.createElement('td');
      elementTextTd.className = "textColumn";
      elementTr.appendChild(elementTextTd);
      let elementButtonTd = document.createElement('td');
      elementButtonTd.className = "buttonColumn";
      elementTr.appendChild(elementButtonTd);
      let elementUl = document.createElement('ul');
      elementUl.style.marginTop = "0";
      elementUl.style.marginBottom = "0";

      for (let i = 0; i < len; i++) {
        let favoriteTextItem = document.createElement('div');
        favoriteTextItem.textContent =  `${texts[i]} - [${langs[i]}]`;

        let buttonContainer = document.createElement('div');
        elementButtonTd.appendChild(buttonContainer);

        let ggSpeakFavoriteListItemButton = document.createElement('button');
        ggSpeakFavoriteListItemButton.textContent = 'G';
        let msSpeakFavoriteListItemButton = document.createElement('button');
        msSpeakFavoriteListItemButton.textContent = 'M';
        ggSpeakFavoriteListItemButton.addEventListener('click', function() {
          const index = Array.from(favoriteTable.children).indexOf(elementTr);
          ggSpeak(...sentenceSplit(favoriteTextItem.textContent));
        });
        msSpeakFavoriteListItemButton.addEventListener('click', function() {
          const index = Array.from(favoriteTable.children).indexOf(elementTr);
          msSpeak(...sentenceSplit(favoriteTextItem.textContent));
        });
        buttonContainer.appendChild(ggSpeakFavoriteListItemButton);
        buttonContainer.appendChild(msSpeakFavoriteListItemButton);

        if (i === 0) {
          elementTextTd.appendChild(favoriteTextItem);
          elementTextTd.appendChild(elementUl);
          let removeFavoriteListItemButton = document.createElement('button');
          removeFavoriteListItemButton.textContent = '⛔';
          removeFavoriteListItemButton.style.fontSize = '10px';
          removeFavoriteListItemButton.addEventListener('click', function() {
            elementTr.remove();
            const index = Array.from(favoriteTable.children).indexOf(elementTr);
            removeFromFavoriteTextConfig(index);
          });
          buttonContainer.appendChild(removeFavoriteListItemButton);
        }
        else {
          let elementLi = document.createElement('li');
          elementUl.appendChild(elementLi);
          elementLi.appendChild(favoriteTextItem);
        }
      }
    }

    async function ggSpeakReadingList(ggAudioList, repeatTime) {
      if (ggSpeakAudio) {
        ggSpeakAudio.pause();
      }
      var totalRepeatTime = ggAudioList.length * Math.abs(repeatTime);
      var currentAudioIndex = 0;
      console.log("🗃️ ggAudioList.length:", ggAudioList.length, "| totalRepeatTime:", totalRepeatTime);
      ggSpeakAudio.addEventListener('ended', function() {
        currentAudioIndex++;
        if (currentAudioIndex < totalRepeatTime) {
          ggSpeakAudio.pause();
          var i = currentAudioIndex % ggAudioList.length;
          ggSpeakAudio.src = ggAudioList[i];
          ggSpeakAudio.play();
        }
      });
      ggSpeakAudio.src = ggAudioList[currentAudioIndex];
      ggSpeakAudio.play();
    }
    async function ggSpeakSingleAudioOfList(index) {
      if (ggSpeakAudio) {
        ggSpeakAudio.pause();
      }
      ggSpeakAudio.src = ggAudioList[index];
      ggSpeakAudio.play();
    }

    async function msSpeakReadingList(msAudioList, repeatTime) {
      if (msSpeakAudio) {
        msSpeakAudio.pause();
      }
      var totalRepeatTime = msAudioList.length * Math.abs(repeatTime);
      console.log("🗃️ msAudioList.length:", msAudioList.length, " | totalRepeatTime:", totalRepeatTime);
      function msListPlayAudio(currentAudioIndex) {
        if (currentAudioIndex >= totalRepeatTime) return;
        var i = currentAudioIndex % msAudioList.length;
        var audioDataCopy = msAudioList[i].slice();
        const audioData = msAudioList[i];
        const audioBlob = new Blob([audioData], { type: 'audio/mpeg' });
        msSpeakAudio.src = URL.createObjectURL(audioBlob);
        msSpeakAudio.onended = function() {
          msAudioList[i] = audioDataCopy;
          msListPlayAudio(currentAudioIndex + 1);
        };
        msSpeakAudio.play();
      }
      msListPlayAudio(0);
    }
    async function msSpeakSingleAudioOfList(index) {
      if (msSpeakAudio) {
        msSpeakAudio.pause();
      }
      const audioData = msAudioList[index].slice();
      const audioBlob = new Blob([audioData], { type: 'audio/mpeg' });
      msSpeakAudio.src = URL.createObjectURL(audioBlob);
      msSpeakAudio.play();
    }

    async function ggDetectLanguage(text) {
      const url = `https://translation.googleapis.com/language/translate/v2/detect?key=${gcpApiKey}`;
      const data = {
        q: text
      };
      try {
        const response = await fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data),
        });
        const responseData = await response.json();
        var detectedLanguage = responseData.data.detections[0][0].language;
        var confidence = responseData.data.detections[0][0].confidence;
        console.log(`🔍 Detected Language: ${detectedLanguage} (Confidence: ${confidence})`);
        if (detectedLanguage === "zh-CN") {
          detectedLanguage = "zh-TW";
        }
        if ((detectedLanguage === "zh-CN" || detectedLanguage === "zh-TW") && confidence < 0.93) {
          detectedLanguage = "ja";
        }
        if (detectedLanguage === "und") {
          detectedLanguage = "en";
        }
        return detectedLanguage;
      } catch (error) {
        console.error('ggDetectLanguage Error:', error);
      }
    }

    async function detectLanguageFromMyServer(text) {
      try {
        var server_destination = LOCAL_TEST ? "http://localhost:3001/detect-language" : "https://snsmile.site:3001/detect-language";
        const response = await fetch(server_destination, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            text: text
          })
        })
        const data = await response.json();
        return data.language;
      } catch (error) {
       console.error('Error:', error);
       return text + "🌐🚨";
      }
    }

    async function autoDetectTranslate(text, languageSelect=undefined) {
      console.log(`🔍 autoDetectTranslate(${text})`);
      var sourceLanguage;
      if (gcpApiKey) {
        var sourceLanguage = await ggDetectLanguage(text);
        console.log("👁️‍🗨️ ggDetectLanguage():", sourceLanguage);
      }
      else {
        var sourceLanguage = await detectLanguageFromMyServer(text);
        console.log("🦉 detectLanguageFromMyServer():", sourceLanguage);
      }
      if (!sourceLanguage) {
        if (languageSelect) {
          var sourceLanguage = languageSelect.value;
        }
        else {
          var sourceLanguage = languageSelects[0].value;
        }
      }
      if (languageSelect !== undefined) {
        languageSelect.value = sourceLanguage;
      }
      return sourceLanguage;
    }

    function ggTranslate(text) {
      if (!text) {
        text = $("#inputArea").val();
      }
      if (googleScriptKey) {
        query = `https://script.google.com/macros/s/${googleScriptKey}/exec?`
          + `text=${text}`
          + `&source=${sourceLanguage}`
          + `&target=${targetLanguage}`;
        xmlRequest.open('GET', query, true);
        xmlRequest.onreadystatechange = function(){
          if (xmlRequest.readyState === 4 && xmlRequest.status === 200){
            return xmlRequest.responseText;
          }
        }
        xmlRequest.send(null);
      }
    }

    var targetLanguages;
    async function getTargetLanguages(sourceLanguage="") {
      if (!sourceLanguage) {
        sourceLanguage = await autoDetectTranslate(texts[0].textContent);
      }
      targetLanguages = [];
      targetLanguages.push(sourceLanguage);
      for (let i = 0; i <= topTranslationCount; i++) {
        if (languageSelects[i].value != sourceLanguage) {
          targetLanguages.push(languageSelects[i].value);
        }
        displayedTextLanguageSelects[i].value = targetLanguages[i];
      }
    }

    function jpExpWebUpdate(speechText) {
      if (jpExpWebTop.style.display === 'block' || jpExpWebBot.style.display === 'block') {
        var noSpaceSpeechText = speechText.replace(/\s+/g, "");
        var encodedSpeechText = encodeURIComponent(noSpaceSpeechText);
        var ichimoe_url = "https://ichi.moe/cl/qr/?q=" + encodedSpeechText;
        if (jpExpWebTop.style.display !== 'none') {
          jpExpWebTop.src = ichimoe_url;
        }
        if (jpExpWebBot.style.display !== 'none') {
          jpExpWebBot.src = ichimoe_url;
        }
      }
    }
    var textTimestampNow = -1;
    async function speechTranslate(speechText, sourceLanguage="", isAutoDetect=false, languageSelect=undefined, willUpdateHistoryTexts=true) {
      if (!speechText) return;
      if (!sourceLanguage || isAutoDetect) {
        sourceLanguage = await autoDetectTranslate(speechText, languageSelect);
      }
      textTimestampNow = getRandomInteger(1, 65535);
      let textTimestamp = textTimestampNow;
      updateText(0, speechText, textTimestamp, willUpdateHistoryTexts, sourceLanguage);
      console.log(`🔡 speechTranslate(): speechText = ${speechText}, sourceLanguage = ${sourceLanguage}`);
      if (sourceLanguage === "ja") {
        jpExpWebUpdate(speechText);
      }
      languagePosIdMap[sourceLanguage] = 0;
      await getTargetLanguages(sourceLanguage);
      if (googleScriptKey) {
        const requestsPromises = [];
        for (let i = 1; i <= translationCount; i++) {
          const targetLanguage = targetLanguages[i];
          const promise = new Promise((resolve, reject) => {
            const query = `https://script.google.com/macros/s/${googleScriptKey}/exec?`
              + `text=${speechText}`
              + `&source=${sourceLanguage}`
              + `&target=${targetLanguage}`;
            const xhr = new XMLHttpRequest();
            xhr.open('GET', query, true);
            xhr.onreadystatechange = async function () {
              if (xhr.readyState === 4) {
                if (xhr.status === 200) {
                  if (targetLanguage === "ja") {
                    jpExpWebUpdate(xhr.responseText);
                  }
                  languagePosIdMap[targetLanguage] = i;
                  updateText(i, xhr.responseText, textTimestamp, willUpdateHistoryTexts, targetLanguage);
                  resolve();
                } else {
                  reject(new Error('Failed to finish speechTranslate()'));
                }
              }
            };
            xhr.send();
          });
          requestsPromises.push(promise);
        }
        return Promise.all(requestsPromises);
      } else {
        return Promise.resolve();
      }
    }
    function toggleWidgetArea(widgetName, button) {
      var widget = document.getElementById(widgetName);
      var splitPos = button.innerHTML.lastIndexOf(' ');
      var buttonText = button.innerHTML.substr(0, splitPos);
      var trigger = button.innerHTML.substr(splitPos + 1);
      // length('🟢') = 2; length('❌') = 1;
      trigger = trigger === '🟢' ? '❌' : '🟢';
      button.innerHTML = `${buttonText} ${trigger}`;
      widget.style.display = trigger === '🟢' ? 'block' : 'none';
      // compact = inline || block
      var buttonClicked = !toggleButtonsClickedMap.get(buttonText);
      toggleButtonsClickedMap.set(buttonText, buttonClicked);
      configs[autoSID].toggleButtonsClickedList = configs[autoSID].toggleButtonsClickedList.filter(item => item[0] !== buttonText);
      if (buttonClicked) {
        configs[autoSID].toggleButtonsClickedList.push([buttonText, 1]);
      }
      saveConfigStorage();
    }
    function toggleFixedHeight() {
      fixedHeightToggleButton.innerHTML = fixedHeightToggleButton.innerHTML === "⚽️" ? "🏀" : "⚽️";
    }

    const excludedButtonNames = ["Recognition", "Text Record"];
    function minimalistTheme() {
      const buttons = layoutContainer.querySelectorAll('button');
      buttons.forEach(button => {
        var splitPos = button.innerHTML.lastIndexOf(' ');
        var trigger = button.innerHTML.substr(splitPos + 1);
        var name = button.innerHTML.substr(0, splitPos);
        if (!excludedButtonNames.includes(name) && trigger === "🟢") {
          button.click();
        }
      });
    }
    function saveConfigStorage() {
      var configJSON = JSON.stringify(configs);
      localStorage.setItem('snowyTranslatorConfig', configJSON);
    }
    function saveTextConfigStorage(configID) {
      // console.log(`🗃️ saveTextConfigStorage`);
      var configJSON = JSON.stringify(textConfig);
      localStorage.setItem(`snowyTranslatorTextConfig[${configID}]`, configJSON);
    }
    function saveFavoriteTextConfigStorage() {
      var configJSON = JSON.stringify(favTextConfig);
      localStorage.setItem(`snowyTranslatorFavoriteTextConfig`, configJSON);
    }
    function loadConfigStorage() {
      console.log("⏳ loadConfigStorage():");
      if (localStorage.getItem('snowyTranslatorConfig')) {
        configs = JSON.parse(localStorage.getItem('snowyTranslatorConfig'));
      }
    }
    function loadTextConfigStorage(configID) {
      console.log("⏳ loadTextConfigStorage():");
      if (localStorage.getItem(`snowyTranslatorTextConfig[${configID}]`)) {
        textConfig = JSON.parse(localStorage.getItem(`snowyTranslatorTextConfig[${configID}]`));
      }
    }
    function loadFavoriteTextConfigStorage() {
      if (!localStorage.getItem('snowyTranslatorFavoriteTextConfig')) {
        return;
      }
      favTextConfig = JSON.parse(localStorage.getItem(`snowyTranslatorFavoriteTextConfig`));
      if (favoriteTable.rows.length > 0 || !favTextConfig.favoriteTexts) return;
      for (let i = 0; i < favTextConfig.favoriteTexts.length; i++) {
        if (favTextConfig.favoriteTexts[i][0]) {
          addToFavoriteList(favTextConfig.favoriteTexts[i], favTextConfig.favoriteTextLanguages[i], favTextConfig.favoriteTexts[i].length);
        }
      }
    }
    function updatePageColor(color="") {
      if (color === "") color = pageColorPicker.value;
      else pageColorPicker.value = color;
      color = color.toUpperCase();
      pageColorValue.innerHTML = color;
      document.body.style.backgroundColor = color;
      configs[autoSID].pageColor = color;
      saveConfigStorage();
    }
    function updateCurtainColor(color="") {
      if (color === "") color = curtainColorPicker.value;
      else curtainColorPicker.value = color;
      color = color.toUpperCase();
      curtainColorValue.innerHTML = color;
      speechTextArea.style.background = color;
      configs[autoSID].curtainColor = color;
      saveConfigStorage();
    }
    function updateCurtainHeightPre(value="") {
      if (value === "") value = curtainHeightSlider.value;
      else {
        value = Math.min(value, 2000);
        curtainHeightSlider.value = value;
      }
      let sum = parseInt(textMarginBottomSlider.value, 10) + 10;
      for (let i = 0; i <= translationCount; i++) sum += parseInt(textMarginSliders[i].value, 10);
      if (sum > value) {
        value = sum;
        curtainHeightSlider.value = value;
      }
      curtainHeightValue.value = value;
      configs[autoSID].curtainHeight = value;
    }
    function updateCurtainHeight(value="") {
      updateCurtainHeightPre(value);
      saveConfigStorage();
      adjustSpeechTextAreaHeight();
    }
    function updateCurtainWidthPre(value="") {
      if (value === "") value = curtainWidthSlider.value;
      else {
        value = Math.min(value, 2000);
        curtainWidthSlider.value = value;
      }
      curtainWidthValue.value = value;
      const screenWidth = window.innerWidth || document.documentElement.clientWidth;
      if (screenWidth >= 1001 || screenWidth >= value) {
        speechTextArea.style.width = value + "px";
      }
      configs[autoSID].curtainWidth = value;
    }
    function updateCurtainWidth(value="") {
      updateCurtainWidthPre(value)
      saveConfigStorage();
    }
    function updateDisplayedText(id, speechText) {
      for (let j = 0; j < 2; j++) {
        strokeTexts[id][j].innerHTML = "";
      }
      displayedTexts[id].textContent = speechText;
      displayedTexts[id].setAttribute('stroke-data', speechText);
      if (speechText) adjustSpeechTextAreaHeight();
      configs[autoSID].displayedTexts[id] = speechText;
      saveConfigStorage();
    }
    function updateEmojiText(speechText, textTimestamp) {
      if (textTimestamp == textTimestampNow) {
        emojiText.textContent = speechText;
        if (speechText) adjustSpeechTextAreaHeight();
      }
    }

    var globalDebugTimestamp = 0; // console.log(`[${globalDebugTimestamp += 1}]`);
    function updateText(id, speechText, textTimestamp, willUpdateHistoryTexts=true, language="") {
      if (textTimestamp == textTimestampNow) {
        texts[id].innerHTML = speechText;
        configs[autoSID].texts[id] = speechText;
        updateDisplayedText(id, speechText);
      }
      if (speechText.trim() === "") return;

      if (willUpdateHistoryTexts) {
        timeTextUpdated[id] = textTimestamp;
        for (let i = 1; i <= translationCount; i++) {
          if (timeTextUpdated[i] !== timeTextUpdated[0]) {
            // console.log("🕒 Texts are not synced - timeTextUpdated:", timeTextUpdated);
            return;
          }
        }
        console.log(`⏰ All Texts Are Updated: ${timeTextUpdated}`);

        for (let i = 0; i <= topTranslationCount; i++) {
          if (!isRecognizing && textTimestamp != -1 && displayedTextLanguageSelects[i].value === "en" && textEnglishIpaToggleButton.innerText === "🌱") {
            englishIpaFetchFromMyServer(texts[i].textContent)
            .then((html) => {
              updateEnglishIpaText(i, html, textTimestamp);
            })
            .catch((error) => console.error(error));
          }
          if (!isRecognizing && textTimestamp != -1 && displayedTextLanguageSelects[i].value === "zh-TW" && textChinesePinyinToggleButton.innerText === "🌇") {
            chinesePinyinFetchFromMyServer(texts[i].textContent)
            .then((html) => {
              updateChinesePinyinText(i, html, textTimestamp);
            })
            .catch((error) => console.error(error));
          }
          if (textTimestamp != -1 && displayedTextLanguageSelects[i].value === "ja" && textFuriganaToggleButton.innerText === "🔰") {
            setTimeout(() => {
              furiganaFetchFromMyServer(texts[i].textContent)
              .then((html) => {
                updateFuriganaText(i, html, textTimestamp);
              })
              .catch((error) => console.error(error));
            }, 10);
          }
        }
        if (textTimestamp != -1 && textChatgptEmojiToggleButton.innerText === "🥰") {
          chatGptEmojiFetchFromMyServer(texts[0].textContent)
          .then((html) => {
            updateEmojiText(html, textTimestamp);
          })
          .catch((error) => console.error(error));
        }

        setTimeout(() => {
          var all_texts = `${displayedTexts[0].innerHTML} | ${displayedTexts[1].innerHTML} | ${displayedTexts[2].innerHTML}`;
          if (textChatgptEmojiToggleButton.innerText === "🥰") {
            all_texts += ` | ${emojiText.innerHTML}`;
          }
          updateSpeechList(all_texts);
        }, 5000);

        // pushToHistoryTexts
        if (textConfig.historyTexts.length > 0 && textConfig.historyTexts[textConfig.historyTexts.length - 1][0] === speechText) return;
        textConfig.historyTexts.push([...texts].map(element => element.textContent));
        textConfig.historyTextLanguages.push([...targetLanguages]);
        textConfig.historyTextTimestamps.push(textTimestamp);
        while (textConfig.historyTexts.length > configs[autoSID].historyTextsMaxLength) {
          textConfig.historyTexts.shift() // or textConfig.historyTexts = textConfig.historyTexts.slice(1);
          textConfig.historyTextLanguages.shift();
          textConfig.historyTextTimestamps.shift();
          textConfig.furiganaTexts.shift();
          textConfig.furiganaTextPos.shift();
          textConfig.englishIpaTexts.shift();
          textConfig.englishIpaTextPos.shift();
          textConfig.chinesePinyinTexts.shift();
          textConfig.chinesePinyinTextPos.shift();
        }
        updateHistoryTextCurrentId(textConfig.historyTexts.length - 1);
        saveTextConfigStorage(autoSID);
      }
    }

    function updateHistoryTextCurrentId(pos) {
      configs[autoSID].historyTextsCurrentId = pos;
      historyTextsIdDisplay.innerHTML = `${pos + 1}/${textConfig.historyTexts.length}`;
      saveConfigStorage();
    }
    function showHistoryText(index) {
      if (index < 0 || index >= textConfig.historyTexts.length) return;
      // console.log(`👀 showHistoryText(${index})`);
      updateHistoryTextCurrentId(index);
      textTimestampNow = textConfig.historyTextTimestamps[index];
      for (let i = 0; i <= translationCount; i++) {
        let willUpdateHistoryTexts = false;
        updateText(i, textConfig.historyTexts[index][i], textConfig.historyTextTimestamps[index], willUpdateHistoryTexts);

        displayedTextLanguageSelects[i].value = textConfig.historyTextLanguages[index][i];
        languagePosIdMap[displayedTextLanguageSelects[i].value] = i;
      }
      if (textFuriganaToggleButton.innerText === "🔰") {
        updateRubyText(textConfig.furiganaTextPos[index], textConfig.furiganaTexts[index], textConfig.historyTextTimestamps[index]);
      }
      if (textEnglishIpaToggleButton.innerText === "🌱") {
        updateRubyText(textConfig.englishIpaTextPos[index], textConfig.englishIpaTexts[index], textConfig.historyTextTimestamps[index]);
      }
      if (textChinesePinyinToggleButton.innerText === "🌇") {
        updateRubyText(textConfig.chinesePinyinTextPos[index], textConfig.chinesePinyinTexts[index], textConfig.historyTextTimestamps[index]);
      }
    }
    function getRubyText(html) {
      const rubyTagRegex = /<ruby>(.*?)<\/ruby>/g;
      const rtTagRegex = /<rt>.*?<\/rt>/g;
      var entireRubyText = "";
      const rubyMatches = html.match(rubyTagRegex);
      if (!rubyMatches) {
        return "";
      }
      const rubyTextList = [];
      rubyMatches.forEach((match) => {
        const rtText = match.replace(rtTagRegex, '').replace(/<\/?ruby>/g, '');
        if (rtText.length > 0) {
          rubyTextList.push(rtText);
          entireRubyText += rtText;
        }
      });
      return entireRubyText.replace(/\s+/g, ' ');
    }
    function getRubyTextBottom(html) {
      const rubyTextBottom = html.replace(/<\/?ruby>/g, '').replace(/<rt>.*?<\/rt>/g, '');
      const rubyTextBottomTrimmed = rubyTextBottom.replace(/\s+/g, ' ');
      return rubyTextBottomTrimmed;
    }
    function updateRubyText(id, htmlText, timestamp) {
      if (id < 0 || !htmlText || typeof htmlText === "string" && htmlText.trim() === "") return;
      if (timestamp !== textTimestampNow) {
        console.log(`🎭 id[${id}]: timestamp(${timestamp}) !== textTimestampNow(${textTimestampNow})`);
        return;
      }
      displayedTexts[id].innerHTML = htmlText;
      displayedTexts[id].setAttribute('stroke-data', "");

      for (let layer = 0; layer < 2; layer++) {
        strokeTexts[id][layer].innerHTML = htmlText;
        strokeTexts[id][layer].style.fontSize = displayedTexts[id].style.fontSize; // updateFontSize
        strokeTexts[id][layer].style.fontWeight = displayedTexts[id].style.fontWeight; // updateFontWeight
        strokeTexts[id][layer].style.fontFamily = displayedTexts[id].style.fontFamily; // updateFontFamily
        strokeTexts[id][layer].style.webkitTextStrokeColor = darkModeToggleButton.innerHTML !== "🌜" ? configs[autoSID].textStrokeColors[id][layer] : darkModeStrokeColor; // updateStrokeColor
        strokeTexts[id][layer].style.webkitTextStrokeWidth = darkModeToggleButton.innerHTML !== "🌜" ? configs[autoSID].textStrokeWidths[id][layer] : darkModeStrokeWidth; // updateStrokeWidth
      }
      adjustSpeechTextAreaHeight();
      saveTextConfigStorage(autoSID);
    }

    function copyText(id) {
      var text = document.getElementById(`text-${id}`).textContent;
      text = text.replace(/^\s+/g, '').replace(/\s+/g, ' ');
      navigator.clipboard.writeText(text);
    }
    function clearTexts(firstRow=0, topRow=-1) {
      if (topRow === -1) {
        topRow = topTranslationCount;
      }
      textTimestampNow = -1;
      let textTimestamp = -1;
      let willUpdateHistoryTexts = false;
      for (let i = firstRow; i <= topRow; i++) {
        updateText(i, "", textTimestamp, willUpdateHistoryTexts);
        displayedTextLanguageSelects[i].value = defaultConfig.languages[i];
      }
      targetLanguages = [...defaultConfig.languages];
    }
    function defaultTexts(topRow=-1) {
      if (topRow === -1) {
        topRow = translationCount;
      }
      textTimestampNow = -1;
      let textTimestamp = -1;
      let willUpdateHistoryTexts = false;
      for (let i = 0; i <= topRow; i++) {
        updateText(i, defaultConfig.texts[i], textTimestamp, willUpdateHistoryTexts, defaultConfig.languages[i]);
        displayedTextLanguageSelects[i].value = defaultConfig.languages[i];
      }
      targetLanguages = [...defaultConfig.languages];
      if (textFuriganaToggleButton.innerText === "🔰") {
        updateRubyText(0, defaultConfig.displayedTexts[0], textTimestamp);
      }
      if (textEnglishIpaToggleButton.innerText === "🌱") {
        updateRubyText(1, defaultConfig.displayedTexts[1], textTimestamp);
      }
      if (textChinesePinyinToggleButton.innerText === "🌇") {
        updateRubyText(2, defaultConfig.displayedTexts[2], textTimestamp);
      }
    }
    function updateFontColor(id, color="") {
      if (color === "") color = textColorPickers[id].value;
      else textColorPickers[id].value = color;
      color = color.toUpperCase();
      textColorValues[id].innerHTML = color;
      displayedTexts[id].style.color = color;
      configs[autoSID].textFontColors[id] = color;
      saveConfigStorage();
    }
    function updateFontSize(id, value="") {
      if (value === "") value = textFontSizeSliders[id].value;
      else {
        value = Math.max(value, 1);
        textFontSizeSliders[id].value = value;
      }
      textFontSizeValues[id].innerHTML = value;
      displayedTexts[id].style.fontSize = value + 'px';
      for (let layer = 0; layer < 2; layer++) {
        strokeTexts[id][layer].style.fontSize = value + 'px'; // updateFontSize
      }
      configs[autoSID].textFontSizes[id] = value;
      saveConfigStorage();
    }
    function changeFontSizes(value) {
      for (let i = 0; i <= translationCount; i++) {
        updateFontSize(i, parseInt(textFontSizeSliders[i].value, 10) + value);
      }
    }
    function updateFontWeight(id, value="") {
      if (value === "") value = textFontWeightSliders[id].value;
      else textFontWeightSliders[id].value = value;
      textFontWeightValues[id].innerHTML = value;
      displayedTexts[id].style.fontWeight = value;
      for (let layer = 0; layer < 2; layer++) {
        strokeTexts[id][layer].style.fontWeight = value; // updateFontWeight
      }
      configs[autoSID].textFontWeights[id] = value;
      saveConfigStorage();
    }
    function updateFontFamily(id, value="") {
      if (value === "") value = textFontFamilySelects[id].value;
      else {
        textFontFamilySelects[id].value = value;
      }
      displayedTexts[id].style.fontFamily = value;
      for (let layer = 0; layer < 2; layer++) {
        strokeTexts[id][layer].style.fontFamily = value; // updateFontFamily
      }
      configs[autoSID].textFontFamilies[id] = value;
      saveConfigStorage();
    }
    function updateStrokeColor(id, layer, color="") {
      if (color === "") color = textStrokeColorPickers[id][layer].value;
      else textStrokeColorPickers[id][layer].value = color;
      color = color.toUpperCase();
      textStrokeColorValues[id][layer].innerHTML = color;
      displayedTexts[id].style.setProperty(`--stroke-color-layer-${layer}`, color);
      strokeTexts[id][layer].style.webkitTextStrokeColor = color; // updateStrokeColor
      configs[autoSID].textStrokeColors[id][layer] = color;
      saveConfigStorage();
    }
    function updateStrokeWidth(id, layer, value="") {
      if (value === "") value = textStrokeWidthSliders[id][layer].value;
      else textStrokeWidthSliders[id][layer].value = value;
      textStrokeWidthValues[id][layer].innerHTML = value;
      displayedTexts[id].style.setProperty(`--stroke-width-layer-${layer}`, value + "em");
      strokeTexts[id][layer].style.webkitTextStrokeWidth = value + "em"; // updateStrokeWidth
      configs[autoSID].textStrokeWidths[id][layer] = value;
      saveConfigStorage();
    }
    function updateTextShadow(id, radius="", color="") {
      if (radius === "") radius = textShadowBlurRadiusSliders[id].value;
      else textShadowBlurRadiusSliders[id].value = radius;
      if (color === "") color = textShadowColorPickers[id].value;
      else textShadowColorPickers[id].value = color;
      color = color.toUpperCase();
      textShadowBlurRadiusValues[id].innerHTML = radius;
      textShadowColorValues[id].innerHTML = color;
      displayedTexts[id].style.textShadow = `0 0 ${radius}em ${color}`;
      configs[autoSID].textShadowBlurRadius[id] = radius;
      configs[autoSID].textShadowColors[id] = color;
      saveConfigStorage();
    }
    function updateTextMargin(id, value="") {
      if (value === "") value = textMarginSliders[id].value;
      else textMarginSliders[id].value = value;
      textMarginValues[id].innerHTML = value;
      textMargins[id].style.marginTop = value + "px";
      configs[autoSID].textMargins[id] = value;
      adjustSpeechTextAreaHeight();
      saveConfigStorage();
    }
    function updateTextMarginBottom(value="") {
      if (value === "") value = textMarginBottomSlider.value;
      else textMarginBottomSlider.value = value;
      textMarginBottomValue.innerHTML = value;
      textMarginBottom.style.marginBottom = value + "px";
      configs[autoSID].textMarginBottom = value;
      adjustSpeechTextAreaHeight();
      saveConfigStorage();
    }
    function updateApiKey(id, value="") {
      if (id === 99) {
        let values = value.replace(/[^\w-,]/g, '').split(',');
        for (let i = 0; i < 5; i++) {
          if (i < values.length) updateApiKey(i, values[i]);
        }
        return;
      }
      if (value === "") value = apiKeyInputs[id].value;
      else apiKeyInputs[id].value = value;
      configs[autoSID].apiKeys[id] = value;
      if (id === 0) {
        googleScriptKey = value;
      }
      else if (id === 1) {
        gcpApiKey = value;
      }
      else if (id === 2) {
        azureSpeechSubscriptionKey = value;
      }
      else if (id === 3) {
        chatGptApiKey = value;
      }
      else if (id === 4) {
        azureTranslateSubscriptionKey = value;
      }
      saveConfigStorage();
    }
    function updateIntegerValue(intervalInput, value=-1) {
      if (value === -1) value = intervalInput.value;
      else intervalInput.value = value;
      configs[autoSID][intervalInput.id] = value;
      saveConfigStorage();
    }
    function updateLanguage(id, value="") {
      if (value === "") value = languageSelects[id].value;
      else languageSelects[id].value = value;
      configs[autoSID].languages[id] = value;
      saveConfigStorage();
    }
    function saveConfig(configID) {
      console.log(`💾 Save Config (${configID}) ing...`);
      configs[configID].pageColor = pageColorPicker.value;
      configs[configID].curtainColor = curtainColorPicker.value;
      configs[configID].curtainHeight = curtainHeightSlider.value;
      configs[configID].curtainWidth = curtainWidthSlider.value;
      configs[configID].texts = [...texts].map(element => element.innerHTML);
      configs[configID].displayedTexts = [...displayedTexts].map(element => element.innerHTML);
      configs[configID].textFontColors = [...textColorValues].map(element => element.innerHTML);
      configs[configID].textFontSizes = [...textFontSizeValues].map(element => element.innerHTML);
      configs[configID].textFontWeights = [...textFontWeightValues].map(element => element.innerHTML);
      configs[configID].textFontFamilies = [...textFontFamilySelects].map(element => element.value);
      configs[configID].textStrokeColors = textStrokeColorValues.map(elements => [elements[0].innerHTML, elements[1].innerHTML]);
      configs[configID].textStrokeWidths = textStrokeWidthValues.map(elements => [elements[0].innerHTML, elements[1].innerHTML]);
      configs[configID].textShadowBlurRadius = [...textShadowBlurRadiusValues].map(element => element.innerHTML);
      configs[configID].textShadowColors = [...textShadowColorValues].map(element => element.innerHTML);
      configs[configID].textMargins = [...textMarginValues].map(element => element.innerHTML);
      configs[configID].textMarginBottom = textMarginBottomValue.innerHTML;
      configs[configID].apiKeys = [...apiKeyInputs].map(element => element.value);
      configs[configID].speechOverInterval = speechOverInterval.value;
      configs[configID].speechSplitInterval = speechSplitInterval.value;
      configs[configID].speechClearInterval = speechClearInterval.value;
      configs[configID].translationCount = parseInt(translationCountSelect.value, 10);
      configs[configID].languages = [...languageSelects].map(element => element.value);
      configs[configID].azureVoices = [...azureVoiceSelects].map(element => element.value);
      configs[configID].toggleButtonsClickedList = saveMap(toggleButtonsClickedMap);
      saveConfigStorage();
      configs[configID].historyTextsMaxLength = configs[autoSID].historyTextsMaxLength;
      configs[configID].historyTextsCurrentId = configs[autoSID].historyTextsCurrentId;

      saveConfigStorage();
      saveTextConfigStorage(configID);
      console.log(`💾 Save Config (${configID}) Finished.`);
    }
    function loadConfig(configID) {
      loadConfigStorage();
      if (configID === -1) {
        configs[autoSID] = copyConfig(defaultConfig);
        configID = autoSID;
        textConfig = copyConfig(defaultTextConfig);
      }
      else {
        loadTextConfigStorage(configID);
      }
      saveTextConfigStorage(autoSID);
      loadFavoriteTextConfigStorage();
      console.log(`⏳ Load Config (${configID}) ing...`);

      toggleTranslationCount(configs[configID].translationCount);
      updatePageColor(configs[configID].pageColor);
      updateCurtainColor(configs[configID].curtainColor);
      for (let i = 0; i <= translationCount; i++) {
        updateTextMargin(i, configs[configID].textMargins[i]);
      }
      updateTextMarginBottom(configs[configID].textMarginBottom);
      updateCurtainHeight(configs[configID].curtainHeight);
      updateCurtainWidth(configs[configID].curtainWidth);
      updateIntegerValue(speechOverInterval, configs[configID].speechOverInterval);
      updateIntegerValue(speechSplitInterval, configs[configID].speechSplitInterval);
      updateIntegerValue(speechClearInterval, configs[configID].speechClearInterval);
      updateIntegerValue(recognitionOverInterval_H, configs[configID].recognitionOverInterval_H);
      updateIntegerValue(recognitionOverInterval_M, configs[configID].recognitionOverInterval_M);
      updateIntegerValue(recognitionOverInterval_S, configs[configID].recognitionOverInterval_S);
      toggleTranslationCount(configs[configID].translationCount);
      toggleHistoryTextsMaxLength(configs[configID].historyTextsMaxLength);

      for (let i = 0; i <= translationCount; i++) {
        updateFontColor(i, configs[configID].textFontColors[i]);
        updateFontSize(i, configs[configID].textFontSizes[i]);
        updateFontWeight(i, configs[configID].textFontWeights[i]);
        updateFontFamily(i, configs[configID].textFontFamilies[i]);
        for (let j = 0; j <= 1; j++) {
          updateStrokeColor(i, j, configs[configID].textStrokeColors[i][j]);
          updateStrokeWidth(i, j, configs[configID].textStrokeWidths[i][j]);
        }
        updateTextShadow(i, configs[configID].textShadowBlurRadius[i], configs[configID].textShadowColors[i]);
        updateTextMargin(i, configs[configID].textMargins[i]);
        updateLanguage(i, configs[configID].languages[i]);
        updateAzureVoice(i, configs[configID].azureVoices[i]);
      }
      for (let i = 0; i < apiKeyInputs.length; i++) {
        if (configs[configID].apiKeys[i]) {
          updateApiKey(i, configs[configID].apiKeys[i]);
        }
        else if (apiKeyInputs[i].value) {
          updateApiKey(i);
        }
      }
      if (Array.isArray(configs[configID].toggleButtonsClickedList)) {
        configs[configID].toggleButtonsClickedList.forEach((item) => {
          let key = item[0], value = item[1];
          let step = (value + toggleButtonsCountMap.get(key) - toggleButtonsClickedMap.get(key)) % toggleButtonsCountMap.get(key);
          toggleButtonsCountMap.get(key);
          for (let i = 0; i < step; i ++) {
            updateToggleButtonClick(key);
          }
        });
      }
      var currentScrollY = window.scrollY || window.pageYOffset || document.documentElement.scrollTop;
      if (currentScrollY < 674) {
        JpExpWebTopLayoutAdjust();
      }
      recognitionOverInterval_H.value = configs[autoSID].recognitionOverInterval_H;
      recognitionOverInterval_M.value = configs[autoSID].recognitionOverInterval_M;
      recognitionOverInterval_S.value = configs[autoSID].recognitionOverInterval_S;

      showHistoryText(configs[configID].historyTextsCurrentId);
      console.log(`⏳ Load Config (${configID}) Finsihed.`);
    }
    function updateConfig(configID, key, value) {
      configs[configID][key] = value;
      saveConfig(configID);
    }
    function formatJpExp(jpExp, hasRomaji=true) {
      var elements = jpExp.split('<br>');
      var jpExpAreaLength = document.getElementById("jpExpArea").offsetWidth;
      var jpExpAreaTest = $('#jpExpAreaTest');
      var lineLength = 0;
      var html = "";
      for (let i = 0; i < elements.length; i++) {
        var line = elements[i];
        jpExpAreaTest.html(line);
        sentenceLength = jpExpAreaTest.width();
        if (sentenceLength > jpExpAreaLength) {
          if (i > 0) {
            html += "<br>";
          }
          html += line;
          if (i < elements.length - 1) {
            html += "<br>";
          }
        } else {
          if (lineLength + sentenceLength > jpExpAreaLength) {
            html += "<br>";
            lineLength = 0;
          }
          lineLength += sentenceLength;
          html += line;
        }
      }
      return(html);
    }
    async function scrapeJpExp(text) {
      var jpExp = "";
      try {
        const url = 'https://ichi.moe/cl/qr/?q=' + encodeURIComponent(text);
        const response = await fetch(url);
        const html = await response.text();
        const parser = new DOMParser();
        const soup = parser.parseFromString(html, 'text/html');
        const row_gloss_rows = soup.querySelectorAll('.row.gloss-row:not(.hidden)');
        for (let i = 0; i < row_gloss_rows.length; i++) {
          const row_gloss_row = row_gloss_rows[i];
          const glosses = row_gloss_row.getElementsByClassName('gloss');
          var romaji_str = "";
          jpExp += " 【";
          for (let j = 0; j < glosses.length; j++) {
            const gloss = glosses[j];
            const hiragana = gloss.getElementsByTagName('dt')[0];
            if (j > 0) {
              jpExp += " - ";
              romaji_str += " ";
            }
            var word = hiragana.textContent;
            word = word.replace("1. ", "");
            word = word.replace("【", "<rt>");
            word = word.replace("】", "</rt>");
            word = "<ruby> " + word + "</ruby>";
            const romaji = gloss.getElementsByTagName('em')[0].textContent;
            romaji_str += romaji;
            jpExp += word;
          }
          jpExp += ` | ${romaji_str}】<br> `;
        }
        return jpExp;
      }
      catch (error) {
        console.log(`⚠️ scrapeJpExp: an error occurred: ${error}`);
        return "";
      }
    }
    function japaneseExplanationFileCORS(text = "") {
      if (text === "") {
        text = jpExpInput.value;
        if (text === "") return;
      }
      var jpExpPromise = scrapeJpExp(text);
      jpExpPromise.then(function(jpExp) {
        jpExpArea.html(formatJpExp(jpExp));
      })
    }
    async function furiganaFetchFromMyServer(text = "") {
      if (text === "") {
        return;
      }
      try {
        var server_destination = LOCAL_TEST ? "http://localhost:3001/furigana" : "https://snsmile.site:3001/furigana";
        const response = await fetch(server_destination, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            text: text
          })
        })
        const data = await response.json();
        // var jpExpArea = $('#jpExpArea');
        // jpExpArea.html(response.result);
        return data.result;
      } catch (error) {
        console.error('furiganaFetchFromMyServer() Error:', error);
        return text + "🌐🚨";
      }
    }
    async function furiganaFetchSplittedFromMyServer(text="") {
      // japaneseExplanationFileCORS(text);
      if (text === "") {
        text = $('#jpExpInput').val();
      }
      try {
        var server_destination = LOCAL_TEST ? "http://localhost:3001/formatJpExp" : "https://snsmile.site:3001/formatJpExp";
        const response = await fetch(server_destination, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            text: text
          })
        })
        const data = await response.json();
        var jpExpArea = $('#jpExpArea');
        jpExpArea.html(data.result);
        return data.result;
      } catch (error) {
        console.error('furiganaFetchSplittedFromMyServer() Error:', error);
        return text + "🌐🚨";
      }
    }
    async function englishIpaFetchFromMyServer(text) {
      try {
        var server_destination = LOCAL_TEST ? "http://localhost:3001/englishIpa" : "https://snsmile.site:3001/englishIpa";
        const response = await fetch(server_destination, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            text: text
          })
        })
        const responseText = await response.text();
        return responseText;
      } catch (error) {
        console.error('englishIpaFetchFromMyServer() Error:', error);
        return text + "🌐🚨";
      }
    }
    async function chinesePinyinFetchFromMyServer(text) {
      try {
        var server_destination = LOCAL_TEST ? "http://localhost:3001/chinesePinyin" : "https://snsmile.site:3001/chinesePinyin";
        const response = await fetch(server_destination, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            text: text
          })
        })
        const responseText = await response.text();
        return responseText;
      } catch (error) {
        console.error('chinesePinyinFetchFromMyServer() Error:', error);
        return text + "🌐🚨";
      }
    }
    async function chatGptEmojiFetchFromMyServer(text) {
      try {
        var server_destination = LOCAL_TEST_CHATGPT ? "http://localhost:3002/chatgpt-emoji" : "https://snsmile.site:3002/chatgpt-emoji";

        console.log("chatGptApiKey:", chatGptApiKey);
        const response = await fetch(server_destination, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            text: text,
            apikey: chatGptApiKey
          })
        })
        const responseText = await response.text();
        return responseText;
      } catch (error) {
        console.error('chatGptEmojiFetchFromMyServer() Error:', error);
        return text + "🌐🚨";
      }
    }
  </script>

  <style>
    #favoriteTable {
      word-break: break-word;
      width: 1000px;

      border: 0.2rem outset pink;
      outline: 0.2rem solid khaki;
      box-shadow: 0 0 0 0.4rem skyblue;
      border-radius: 12px;
      margin: 0.2rem;
      outline-offset: 0.4rem;
    }
    #favoriteTable tr {
      border-radius: 10px;
      display:flex;
      flex-direction: row;
    }
    #favoriteTable td {
      border: 1px groove grey;
      text-align: left;
      display: table-cell;
    }
    #favoriteTable button {
      vertical-align: middle;
      height: 20px;
      width: 30px;
    }
    .textColumn {
      width:100%;
    }
    .buttonColumn {
      min-width: 100px;
      width: 100px;
      display: grid;
      align-content: space-evenly;
    }

    @media screen and (max-width: 1000px) {
      #favoriteTable {
        width: 98%;
      }
    }
  </style>

  <span id="audioDownloadContainer" class="phone-invisible" style="display:none">
    <a id="audioDownloadWidget" download style="display:none"> MS Audio Download </a>
    <table style="margin-bottom:3px;">
      <tr>
        <td style="display: table-cell;">
          <button style="font-size: 11px; width:120px; margin-bottom:8px;" id="addAudioDownloadColumnButton" onclick="addAudioDownloadColumn()"> 🌱New Column </button>
          <button style="display:block; font-size: 11px; width:120px; margin-bottom:8px;" title="Split Text of a Table to Multiple Columns." onclick="tableTextSplit()">✂️Split Texts</button>
          <button style="display:block; font-size: 11px; width:120px; margin-bottom:8px;" title="Split Text of a Table to Multiple Columns." onclick="tableTextShowUp()">📊Show Up Texts</button>
          <button style="display:block; font-size: 11px; width:120px; margin-bottom:8px;" title="Split Text of a Table to Multiple Columns." onclick="allAudioDownload()">⬇️Download Audio</button>
        </td>
        <td style="display: table-cell;">
          <textarea id="audioDownloadInputTextArea" rows="6" cols="113"></textarea>
        </td>
      </tr>
    </table>
    <table id="audioDownloadTable" style="margin-bottom:5px;">
    </table>

    <span id="elementTextReplacement" class="phone-invisible">
      <table style="margin-bottom:3px;">
        <tr>
          <td style="display: table-cell;">
            <span> Input Text: </span>
            <textarea id="replacementInputTextArea" rows="1" cols="40"></textarea>
          </td>
          <td style="display: table-cell;">
            <span> Output Text:  </span>
            <textarea id="replacementOutputTextArea" rows="1" cols="40"></textarea>
          </td>
          <td style="display: table-cell;">
            <button id="replacementButton" onclick="elementTextReplace()">Replace Text</button>
          </td>
        </tr>
      </table>
    </span>
  </span>

  <span id="rubyConverterContainer" class="phone-invisible" style="display:none">
    <span>
      <table style="margin-bottom:3px;">
        <tr>
          <td style="display:table-cell;">
            <span style="display: block; font-size: 14px; width:40px; white-space: normal; word-wrap: break-word;"> Input Text: </span>
          </td>
          <td style="display:table-cell;">
            <textarea id="rubyConvertInputTextArea" rows="6" cols="40"></textarea>
          </td>
          <td style="display:table-cell;">
          <span style="display: block; font-size: 14px; width:40px; white-space: normal; word-wrap: break-word;"> Output Text:  </span>
          </td>
          <td style="display:table-cell;">
            <textarea id="rubyConvertOutputTextArea" rows="6" cols="40"></textarea>
          </td>
          <td style="display:table-cell;">
            <button id="rubyConvertButton" style="display: block; width:70px; white-space: normal; word-wrap: break-word; margin-bottom: 5px;" onclick="rubyConvertToTextArea()">Full Convert </button>
            <button id="rubyConvertButton" style="display: block; width:70px; white-space: normal; word-wrap: break-word;" onclick="rubyConvertToTextArea(0)">Clean Convert </button>
          </td>
          <td>
          </td>
        </tr>
      </table>
    </span>
  </span>

  <script>
    function rubyConvert(textInput, code=-1) {
      let textOutput = textInput.replace(/<\/?rb>/g, '').replace(/&nbsp;/g, ''); // remove <rb> and </rb> and
      // textOutput = textOutput.replace(/\s/g, '').replace(/<\/ruby>\s*/g, "</ruby> "); // remove all spaces and reserve exact one space followed;
      textOutput = textOutput.replace(/<ruby>.*?<\/ruby>/g, match => match.replace(/\s+/g, '')) // remove space in <ruby> </ruby>
      textOutput = textOutput.replace(/<\/?ruby>/g, ''); // remove <ruby> and </ruby>
      const rubyRegex = /<rt>(.*?)<\/rt>/g;
      textOutput = textOutput.replace(rubyRegex, (match, furigana) => {
        return code === -1 ? `(${furigana})` : ``;
      });
      textOutput = textOutput.replace(/<[^>]+>/g, '');
      textOutput = textOutput.replace(/^\s+/g, '').replace(/\s+/g, ' ');
      return textOutput;
    }
    function rubyConvertToTextArea(code=-1) {
      const textInput = rubyConvertInputTextArea.value;
      const textOutput = rubyConvert(textInput, code);
      rubyConvertOutputTextArea.value = textOutput;
    }
    function tableTextSplit() {
      for (let i = 0; i < audioDownloadTopColumn; i++) {
        audioDownloadSplitTextAreas[i].value = "";
      }
      var lines = audioDownloadInputTextArea.value.split('\n');
      for (let i = 0; i < lines.length; i++) {
        var segments = lines[i].split('\t');
        for (let j = 0; j < segments.length; j++) {
          audioDownloadSplitTextAreas[j].value += segments[j] + '\n';
        }
      }
    }

    function tableTextShowUp() {
      clearTexts();
      console.log(`📊 tableTextShowUp()`)
      var lines = audioDownloadInputTextArea.value.split('\t');
      textTimestampNow = -123;
      let textTimestamp = -123;
      timeTextUpdated = [-99, -99, -99];
      let willUpdateHistoryTexts = true;
      for (let i = 0; i < lines.length; i++) {
        updateText(i, lines[i], textTimestamp, willUpdateHistoryTexts, defaultConfig.languages[i]);
        audioDownloadSplitTextAreas[i].value = lines[i];
      }
      audioDownloadSplitTextAreas[1].value = lines[1].replace(/^to /, '').replace(/, to /g, ', ');
      audioDownloadSplitTextAreas[3].value = lines[0];
      turnOnJpExpWebTop();
    }

    const optionsByLanguage = {
      "ja":
      `<select id="azureVoiceSelect-Japanese" onchange="updateAzureVoice(0)">
          <option value="ja-JP-NanamiNeural">Nanami</option>
          <option value="ja-JP-KeitaNeural">Keita</option>
          <option value="ja-JP-AoiNeural">Aoi</option>
          <option value="ja-JP-DaichiNeural">Daichi</option>
          <option value="ja-JP-MayuNeural">Mayu</option>
          <option value="ja-JP-NaokiNeural">Naoki</option>
          <option value="ja-JP-ShioriNeural">Shiori</option>
        </select>
      `,
      "en":
      `<select id="azureVoiceSelect-English" onchange="updateAzureVoice(1)">
        <option value="en-US-JennyMultilingualNeural">Jenny Multilingual</option>
        <option value="en-US-JennyNeural">Jenny</option>
        <option value="en-US-GuyNeural">Guy</option>
        <option value="en-US-AriaNeural">Aria</option>
        <option value="en-US-DavisNeural">Davis</option>
        <option value="en-US-AmberNeural">Amber</option>
        <option value="en-US-AnaNeural">Ana</option>
        <option value="en-US-AshleyNeural">Ashley</option>
        <option value="en-US-BrandonNeural">Brandon</option>
        <option value="en-US-ChristopherNeural">Christopher</option>
        <option value="en-US-CoraNeural">Cora</option>
        <option value="en-US-ElizabethNeural">Elizabeth</option>
        <option value="en-US-EricNeural">Eric</option>
        <option value="en-US-JacobNeural">Jacob</option>
        <option value="en-US-JaneNeural">Jane</option>
        <option value="en-US-JasonNeural">Jason</option>
        <option value="en-US-JennyMultilingualV2Neural">Jenny Multilingual V2</option>
        <option value="en-US-MichelleNeural">Michelle</option>
        <option value="en-US-MonicaNeural">Monica</option>
        <option value="en-US-NancyNeural">Nancy</option>
        <option value="en-US-RogerNeural">Roger</option>
        <option value="en-US-RyanMultilingualNeural">Ryan Multilingual</option>
        <option value="en-US-SaraNeural">Sara</option>
        <option value="en-US-SteffanNeural">Steffan</option>
        <option value="en-US-TonyNeural">Tony</option>
        <option value="en-US-AIGenerate1Neural">AIGenerate1</option>
        <option value="en-US-AIGenerate2Neural">AIGenerate2</option>
        <option value="en-US-BlueNeural">Blue</option>
      </select>`,
      "zh-TW":
      `<select id="azureVoiceSelect-Chinese" onchange="updateAzureVoice(2)">
        <option value="zh-TW-HsiaoChenNeural">HsiaoChen</option>
        <option value="zh-TW-YunJheNeural">YunJhe</option>
        <option value="zh-TW-HsiaoYuNeural">HsiaoYu</option>
        <option value="zh-CN-XiaoxiaoNeural">Xiaoxiao</option>
        <option value="zh-CN-YunxiNeural">Yunxi</option>
        <option value="zh-CN-YunjianNeural">Yunjian</option>
        <option value="zh-CN-XiaoyiNeural">Xiaoyi</option>
        <option value="zh-CN-YunyangNeural">Yunyang</option>
        <option value="zh-CN-XiaochenNeural">Xiaochen</option>
        <option value="zh-CN-XiaohanNeural">Xiaohan</option>
        <option value="zh-CN-XiaomengNeural">Xiaomeng</option>
        <option value="zh-CN-XiaomoNeural">Xiaomo</option>
        <option value="zh-CN-XiaoqiuNeural">Xiaoqiu</option>
        <option value="zh-CN-XiaoruiNeural">Xiaorui</option>
        <option value="zh-CN-XiaoshuangNeural">Xiaoshuang</option>
        <option value="zh-CN-XiaoxuanNeural">Xiaoxuan</option>
        <option value="zh-CN-XiaoyanNeural">Xiaoyan</option>
        <option value="zh-CN-XiaoyouNeural">Xiaoyou</option>
        <option value="zh-CN-XiaozhenNeural">Xiaozhen</option>
        <option value="zh-CN-YunfengNeural">Yunfeng</option>
        <option value="zh-CN-YunhaoNeural">Yunhao</option>
        <option value="zh-CN-YunxiaNeural">Yunxia</option>
        <option value="zh-CN-YunyeNeural">Yunye</option>
        <option value="zh-CN-YunzeNeural">Yunze</option>
      </select>`
    }
    function updateVoiceOptions(languageSelect, voiceSelect, voiceLanguage="") {
      if (voiceLanguage) {
        languageSelect.value = voiceLanguage;
      }
      voiceSelect.innerHTML = optionsByLanguage[languageSelect.value];
    }
    var audioDownloadTopColumn = 10;
    var audioDownloadCurrentColumn = 0;
    var audioDownloadColumns = [];
    var audioDownloadLanguageSelects;
    var audioDownloadVoiceSelects;
    function initAudioDownloadColumns() {
      for (let i = 0; i < audioDownloadTopColumn; i ++) {
        const newRow = document.createElement("tr");
        newRow.style.display = "none";
        newRow.innerHTML = `
          <td style="display: table-cell;">
            <select id="audioDownloadLanguageSelect${i}" onchange="updateVoiceOptions(this, this.parentNode.nextElementSibling.querySelector('select'))">
              <option value="ja">🇯🇵</option>
              <option value="en">🇺🇸</option>
              <option value="zh-TW">🇹🇼</option>
            </select>
          </td>
          <td style="display: table-cell;">
            <select id="audioDownloadVoiceSelect${i}">
            </select>
          </td>
          <td>
            <button onclick="msSpeak(this.parentNode.parentNode.querySelector('textarea').value, this.parentNode.parentNode.querySelectorAll('select')[0].value, this.parentNode.parentNode.querySelectorAll('select')[1].value)">🎶</button>
          </td>
          <td>
            <button onclick="audioDownload(this.parentNode.parentNode.querySelector('textarea').value, this.parentNode.parentNode.querySelectorAll('select')[0].value, this.parentNode.parentNode.querySelectorAll('select')[1].value)">⬇️</button>
          </td>
          <td>
            <textarea id="audioDownloadSplitTextArea${i}" rows="2" cols="90"></textarea>
          </td>
        `;
        audioDownloadTable.appendChild(newRow);
        audioDownloadColumns.push(newRow);
      }
      audioDownloadLanguageSelects = document.querySelectorAll('[id^="audioDownloadLanguageSelect"]');
      audioDownloadVoiceSelects = document.querySelectorAll('[id^="audioDownloadVoiceSelect"]');
      audioDownloadSplitTextAreas = document.querySelectorAll('[id^="audioDownloadSplitTextArea"]');
      audioDownloadVoiceSelects.forEach(select => {
        select.innerHTML = optionsByLanguage["ja"];
      });

      addAudioDownloadColumn(languageSelects[0].value, 'ja-JP-AoiNeural');
      addAudioDownloadColumn(languageSelects[1].value, 'en-US-AshleyNeural');
      addAudioDownloadColumn(languageSelects[2].value, 'zh-TW-HsiaoChenNeural'); // 'zh-CN-XiaochenNeural', 'zh-TW-HsiaoChenNeural', 'zh-CN-XiaoyouNeural'
      addAudioDownloadColumn(languageSelects[0].value, 'ja-JP-MayuNeural');
    }
    function addAudioDownloadColumn(audioLanguage="", audioVoice="") {
      if (audioDownloadCurrentColumn + 1 >= audioDownloadTopColumn) return;
      audioDownloadColumns[audioDownloadCurrentColumn].style.display = "table-row";
      if (audioLanguage) {
        updateVoiceOptions(audioDownloadLanguageSelects[audioDownloadCurrentColumn], audioDownloadVoiceSelects[audioDownloadCurrentColumn], audioLanguage);
      }
      if (audioVoice) {
        audioDownloadVoiceSelects[audioDownloadCurrentColumn].value = audioVoice;
      }
      audioDownloadCurrentColumn +=1;
    }

    async function audioDownload(text, sourceLanguage, voice) {
      // console.log(`text:, ${text}; sourceLanguage: ${sourceLanguage}; voice: ${voice}`);
      if (!MSTTS_accessToken) {
        await getMsttsAccessToken();
      }
      const audioData = await getMsAudioData(text, sourceLanguage, voice);
      const audioBlob = new Blob([audioData], { type: 'audio/mpeg' });
      audioDownloadWidget.href = URL.createObjectURL(audioBlob);
      audioDownloadWidget.download = `${voice}[${sanitizeForWindowsFileName(text)}] ${getFormattedTime()}`;
      audioDownloadWidget.click();
    }
    async function allAudioDownload() {
      var audioDownloadTexts = [];
      for (let i = 0; i < audioDownloadCurrentColumn; i++) {
        audioDownloadTexts[i] = audioDownloadSplitTextAreas[i].value.split('\n');
      }
      var topLines = audioDownloadTexts[0].length;
      await getMsttsAccessToken();
      for (let j = 0; j < topLines; j++) {
        for (let i = 0; i < audioDownloadCurrentColumn; i++) {
          if (audioDownloadTexts[i][j]) {
            let text = audioDownloadTexts[i][j];
            let sourceLanguage = audioDownloadLanguageSelects[i].value;
            let voice = audioDownloadVoiceSelects[i].value;
            await audioDownload(text, sourceLanguage, voice);
            await new Promise(resolve => setTimeout(resolve, 1500));
          }
        }
      }
    }

    function captureAndSaveImage() {
      // For Firefox Browser:
      for (let i = 0; i <= translationCount; i++) if (displayedTextLanguageSelects[i].value === "en") {
        var htmlText = displayedTexts[i].innerHTML;
        console.log("captureAndSaveImage1:", htmlText);
        htmlText = htmlText.replace(/ˈ/g, "'"); // ′
        htmlText = htmlText.replace(/<rt>/g, "<rt>&nbsp;");
        htmlText = htmlText.replace(/<\/rt>/g, "&nbsp;</rt>");
        console.log("captureAndSaveImage2:", htmlText);
        displayedTexts[i].innerHTML = htmlText;
        for (let layer = 0; layer < 2; layer++) {
          strokeTexts[i][layer].innerHTML = htmlText;
        }
      }

      const elementToCapture = document.getElementById("speechTextArea");
      html2canvas(elementToCapture).then(function(canvas) {
        const dataURL = canvas.toDataURL("image/png");
        const downloadLink = document.createElement("a");
        downloadLink.href = dataURL;
        downloadLink.download = `[${sanitizeForWindowsFileName(texts[0].textContent)}] ${getFormattedTime()}`;
        downloadLink.click();
      });
    }

    function elementTextReplace() {
      const inputTextArea = document.getElementById('replacementInputTextArea');
      const outputTextArea = document.getElementById('replacementOutputTextArea');
      const replaceFrom = inputTextArea.value;
      const replaceTo = outputTextArea.value;
      const regex = new RegExp(replaceFrom, 'g');
      speechTextArea.innerHTML = speechTextArea.innerHTML.replace(regex, replaceTo);
    }
  </script>

  <span id="textRecordArea" style="display:block">
    <span>
      <button id="readingList_LayoutButton" style="margin-bottom:5px;" onclick="toggleWidgetArea('readingListArea', this)">Reading List ❌</button>
      <span style="margin-left:8px;"></span>
      <button id="favoriteList_LayoutButton" style="margin-bottom:5px;" onclick="toggleWidgetArea('favoriteTableArea', this)">Favorite List ❌</button>
      <span style="margin-left:8px;"></span>
      <button id="speechList_LayoutButton" style="margin-bottom:5px;" onclick="toggleWidgetArea('speechListArea', this)">Speech List ❌</button>
    </span>

    <span id="readingListArea" style="display:none; margin-bottom:8px;">
      <button style="font-size: 8px; margin-bottom:8px;" onclick="clearReadingList()">Clear - Reading List 🆑</button>
      <ul id="readingList"></ul>
      <span id="readingListTotalCount"></span>
    </span>

    <span id="favoriteTableArea" style="display:none; margin-bottom:8px;">
      <button style="font-size: 8px; margin-bottom:8px;" onclick="clearFavoriteList()">Clear - Favorite List 🆑</button>
      <table id="favoriteTable"></table>
    </span>

    <span id="speechListArea" style="display:none; margin-bottom:8px;">
      <button style="font-size: 8px; margin-bottom:8px;" onclick="clearSpeechList()">Clear - Speech List 🆑</button>
      <ul id="speechList" style="text-align: left; list-style-type:decimal;"></ul>
      <span id="speechListTotalCount"></span>
    </span>
  </span>


  <style>
    .row-container ruby{
      /* border: 0.4px dashed grey; */
      padding: 1px;
    }
  </style>

  <br>
  <span style="display: block">
    <div class="row-container">
      <ruby> 日本語<rt>にほんご</rt> &nbsp; </ruby>
      <ruby> 勉強<rt>べんきょう</rt> の &nbsp; </ruby>
      <ruby> 為<rt>ため</rt> に &nbsp; </ruby>
      <ruby> 自分<rt>じぶん</rt> で &nbsp; </ruby>
      <ruby> このサイトを<rt>.</rt> &nbsp; </ruby>
      <ruby> 作<rt>つく</rt> った &nbsp; </ruby>
      <ruby> by snowy_smile <rt>.</rt> </ruby>
    </div>
  </span>
  <script>
    var darkModeBackgroundColor = "#222";
    var darkModeCurtainColor = "#202020";
    var darkModeTextColor = "#FFF";
    var darkModeStrokeColor = "#000";
    var darkModeStrokeWidth = "0.5em";
    function toggleDarkMode() {
      darkModeToggleButton.innerHTML = darkModeToggleButton.innerHTML === "🌞" ? "🌜" : "🌞";
      document.body.classList.toggle('dark-mode');
      if (document.body.classList.contains('dark-mode')) {
        document.body.style.backgroundColor = darkModeBackgroundColor;
        speechTextArea.style.background = darkModeCurtainColor;
        for (let i = 0; i <= topTranslationCount; i++) {
          displayedTexts[i].style.color = darkModeTextColor;
          displayedTexts[i].style.setProperty(`--stroke-color-layer-${darkModeStrokeColor}`);
          displayedTexts[i].style.setProperty(`--stroke-width-layer-${darkModeStrokeWidth}`);
          strokeTexts[i][0].style.webkitTextStrokeColor = darkModeStrokeColor; // updateStrokeColor
          strokeTexts[i][0].style.webkitTextStrokeWidth = darkModeStrokeWidth; // updateStrokeWidth
        }
      }
      else {
        updatePageColor();
        updateCurtainColor();
        for (let i = 0; i <= topTranslationCount; i++) {
          updateFontColor(i);
          for (let j = 0; j < 2; j++) {
            updateStrokeColor(i, j);
            updateStrokeWidth(i, j);
            strokeTexts[i][j].style.webkitTextStrokeColor = configs[autoSID].textStrokeColors[i][j];
            strokeTexts[i][j].style.webkitTextStrokeWidth = configs[autoSID].textStrokeWidths[i][j];
          }
        }
      }
    }
  </script>
  <script>
    var specialLayoutList = ['🔄','🎐', '🌈'];
    var specialLayoutBackgroundColors = ["", "#B8B8B8", "#E8E8E8"];
    var specialLayoutCurtainColors = ["", "#C4C4C4", "#9ACD32"];
    var specialLayoutTextColor = ["", "#FFF", "#333"];
    var specialLayoutStrokeColor = [[""], ["#000"], ["#FFF"]];
    var specialLayoutStrokeWidth = [[""], ["0.2em"], ["0.15em"]];
    var specialLayoutStrokeColorOut = [[""], ["#ADF3FF", "#FFEC8F", "#FF94A9"], ["#1FDDFF", "#FFD500", "#FF0033"]];
    var specialLayoutStrokeWidthOut = [[""], ["0.5em"], ["0.5em"]];
    function toggleSpecialLayout() {
      let index = specialLayoutList.findIndex(item => item === specialLayoutToggle3Button.innerHTML);
      index = (index + 1) % specialLayoutList.length;
      specialLayoutToggle3Button.innerHTML = specialLayoutList[index];
      if (darkModeToggleButton.innerHTML !== "🌞") return;
      if (index === 0) {
        updatePageColor();
        updateCurtainColor();
        for (let i = 0; i <= topTranslationCount; i++) {
          updateFontColor(i);
          for (let j = 0; j < 2; j++) {
            updateStrokeColor(i, j);
            updateStrokeWidth(i, j);
            strokeTexts[i][j].style.webkitTextStrokeColor = configs[autoSID].textStrokeColors[i][j];
            strokeTexts[i][j].style.webkitTextStrokeWidth = configs[autoSID].textStrokeWidths[i][j];
          }
        }
      }
      else {
        document.body.style.backgroundColor = specialLayoutBackgroundColors[index];
        speechTextArea.style.background = specialLayoutCurtainColors[index];
        for (let i = 0; i <= topTranslationCount; i++) {
          displayedTexts[i].style.color = specialLayoutTextColor[index];
          let color = specialLayoutStrokeColor[index][i %  specialLayoutStrokeColor[index].length];
          let width = specialLayoutStrokeWidth[index][i %  specialLayoutStrokeWidth[index].length];
          displayedTexts[i].style.setProperty(`--stroke-color-layer-${color}`);
          displayedTexts[i].style.setProperty(`--stroke-width-layer-${width}`);
          strokeTexts[i][0].style.webkitTextStrokeColor = color; // updateStrokeColor
          strokeTexts[i][0].style.webkitTextStrokeWidth = width; // updateStrokeWidth
          if (specialLayoutStrokeWidthOut[index]) {
            let color = specialLayoutStrokeColorOut[index][i %  specialLayoutStrokeColorOut[index].length];
            let width = specialLayoutStrokeWidthOut[index][i %  specialLayoutStrokeWidthOut[index].length];
            displayedTexts[i].style.setProperty(`--stroke-color-layer-${color}`);
            displayedTexts[i].style.setProperty(`--stroke-width-layer-${width}`);
            strokeTexts[i][1].style.webkitTextStrokeColor = color; // updateStrokeColor
            strokeTexts[i][1].style.webkitTextStrokeWidth = width; // updateStrokeWidth
          }
        }
      }
    }
    function togglefontSize() {
      fontSizeToggleButton.innerHTML = fontSizeToggleButton.innerHTML === "👘" ? "👚" : "👘";
      if (fontSizeToggleButton.innerHTML === "👘") {
        var boldFontWeights = [700, 700, 600];
        for (let i = 0; i <= translationCount; i++) {
          updateFontWeight(i, boldFontWeights[i]);
        }
      }
      else {
        for (let i = 0; i <= translationCount; i++) {
          updateFontWeight(i, defaultConfig.textFontWeights[i]);
        }
      }
    }
    function toggleCurtainLock() {
      curtainLockToggleButton.innerHTML = curtainLockToggleButton.innerHTML === "🔓"
      ? "🔐" : "🔓";
    }
  </script>
  <script>
    function updateScreenWidth() {
      const screenWidth = window.innerWidth || document.documentElement.clientWidth;
      if (screenWidth % 100 === 0) {
        console.log("🖥️ screenWidth:", screenWidth);
      }
      if (screenWidth < speechTextArea.style.width.replace("px", "")) {
        speechTextArea.style.maxWidth = "95%";
        speechTextArea.style.width = "95%";
      }
    }
    window.addEventListener('resize', updateScreenWidth);
    // updateScreenWidth();
  </script>
  <script>
    function adjustSpeechTextAreaHeight() {
      if (curtainLockToggleButton.innerHTML === "🔐") return;
      speechTextArea.style.height = curtainHeightValue.value + "px";
      if (!texts[0].textContent) return;
      if (fixedHeightToggleButton.innerHTML === "⚽️") {
        var fixedStyleHeight = parseInt(speechTextArea.style.height.replace("px", ""), 10);
        if (DEBUG_MODE) console.log(`⚽️ [~] scrollHeight: [${speechTextArea.scrollHeight}]; fixedStyleHeight: [${fixedStyleHeight}]`);
        var fontSizes = [];
        for (let i = 0; i <= topTranslationCount; i++) {
          fontSizes[i] = parseInt(displayedTexts[i].style.fontSize.replace("px", ""), 10);
        }
        fontSizes[0] = Math.max(10, fontSizes[0]);
        while (speechTextArea.scrollHeight <= fixedStyleHeight) {
          if (DEBUG_MODE) console.log(`⚽️ [<=] scrollHeight: [${speechTextArea.scrollHeight}]; fixedStyleHeight: [${fixedStyleHeight}]; fontsize=${fontSizes[0]}`);
          for (let i = 0; i <= topTranslationCount; i++) {
            fontSizes[i] = Math.ceil(fontSizes[i] * 1.05);
            updateFontSize(i, fontSizes[i]);
            /* displayedTexts[i].style.fontSize = fontSizes[i] + "px";
            for (let layer = 0; layer < 2; layer++) {
              strokeTexts[i][layer].style.fontSize = fontSizes[i] + "px";
            }*/
          }
          if (speechTextArea.scrollHeight > fixedStyleHeight) break;
        }
        while (speechTextArea.scrollHeight >= fixedStyleHeight) {
          if (DEBUG_MODE) console.log(`[>=] scrollHeight: [${speechTextArea.scrollHeight}]; fixedStyleHeight: [${fixedStyleHeight}]; fontsize=${fontSizes[0]}`);
          for (let i = 0; i <= topTranslationCount; i++) {
            fontSizes[i] = Math.floor(fontSizes[i] * 0.95);
            updateFontSize(i, fontSizes[i]);
            /* displayedTexts[i].style.fontSize = fontSizes[i] + "px";
            for (let layer = 0; layer < 2; layer++) {
              strokeTexts[i][layer].style.fontSize = fontSizes[i] + "px";
            } */
          }
          if (speechTextArea.scrollHeight <= fixedStyleHeight) break;
        }
      }
      speechTextArea.style.height = (parseInt(speechTextArea.scrollHeight, 10) + 15) + 'px';
    }
    adjustSpeechTextAreaHeight();
  </script>

  <script> // Start
    LOCAL_TEST = 0 ? true : false;
    DEBUG_MODE = 0 ? true : false;
    LOCAL_TEST_CHATGPT = 1 ? true : false;
    var clearConfigs = 0 ? true : false;
    if (clearConfigs) {
      localStorage.removeItem('snowyTranslatorConfig');
      for (let configID = 0; configID <= 2; configID++) {
        localStorage.removeItem(`snowyTranslatorTextConfig[${configID}]`);
      }
      localStorage.removeItem(`snowyTranslatorFavoriteTextConfig`);
      // localStorage.clear();
    }
    generateAllFontAreaCode();
    initLayoutButtons();
    initToggleButtons();
    loadConfig(autoSID);
    initAudioDownloadColumns();
  </script>
  <script>
    // method A
    window.addEventListener("load", function() {
      var currentTime = new Date().toLocaleTimeString();
      console.log("🎉 windowOnLoad(): Page has completely finished loading at " + currentTime);
      updateTextMarginBottom(); // To fix the margin loading issue
      // tasks: ...
    });
    // method B
    document.addEventListener("DOMContentLoaded", function() {
      var currentTime = new Date().toLocaleTimeString();
      console.log("🎉 DOMContentLoaded(): page has been generally loaded at " + currentTime);
      // tasks:
      initSpecialLayoutButtons();
    });
  </script>
  <span style="display: none">
    <a href="https://wicg.github.io/speech-api" target="_blank">Speech Recognition</a>
    <a href="https://developer.mozilla.org/en-US/docs/Web/HTML" target="_blank">Web HTML Study</a>
    <a href="https://www.tamasoft.co.jp/en/general-info/unicode.html" target="_blank">All Unicode Table</a>
    <a href="https://www.ssec.wisc.edu/~tomw/java/unicode.html" target="_blank">All Unicode Explaination</a>
    textId = 2023-0906-0604;
  </span>
</body>
</html>
